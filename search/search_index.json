{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FactDb","text":"<p>[!CAUTION] This gem is under active development. APIs and features may change without notice. See the CHANGELOG for details.</p> \"Do you swear to add the facts and only the facts?\"  FactDb implements the Event Clock concept - a powerful approach to capturing organizational knowledge through temporal facts. Every fact has explicit validity periods (<code>valid_at</code>/<code>invalid_at</code>) so you always know when information became true and when it changed. The system resolves entity mentions to canonical identities, supports aliases and fuzzy matching, and maintains complete audit trails linking every fact back to its source content. Whether you're tracking employee roles, organizational changes, or any evolving information, FactDb gives you a queryable timeline of truth."},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Temporal Facts - Track facts with validity periods, knowing when information became true and when it changed</li> <li>Entity Resolution - Resolve mentions to canonical entities with alias support and fuzzy matching</li> <li>Audit Trails - Every fact links back to source content for full provenance</li> <li>Multiple Extractors - Extract facts manually, via LLM, or with rule-based patterns</li> <li>Semantic Search - Built on PostgreSQL with pgvector for vector similarity search</li> <li>Concurrent Processing - Batch process content with parallel pipelines</li> </ul>"},{"location":"#quick-example","title":"Quick Example","text":"<pre><code>require 'fact_db'\n\n# Initialize the facts instance\nfacts = FactDb.new\n\n# Ingest content\nsource = facts.ingest(\n  \"Paula Chen joined Microsoft as Principal Engineer on January 10, 2024.\",\n  type: :email,\n  captured_at: Time.current\n)\n\n# Extract facts using LLM\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\n# Query current facts about Paula\ncurrent_facts = facts.query_facts(entity: paula.id)\n\n# Query facts valid at a specific point in time\nhistorical_facts = facts.facts_at(Date.parse(\"2023-06-15\"), entity: paula.id)\n\n# Build a timeline\ntimeline = facts.timeline_for(paula.id)\n</code></pre>"},{"location":"#the-event-clock-concept","title":"The Event Clock Concept","text":"<p>The Event Clock model organizes information into three layers:</p> <pre><code>graph TB\n    subgraph Content[\"Content Layer (Immutable)\"]\n        C1[Email]\n        C2[Document]\n        C3[News Article]\n    end\n\n    subgraph Entities[\"Entity Layer\"]\n        E1[Paula Chen]\n        E2[Microsoft]\n    end\n\n    subgraph Facts[\"Fact Layer (Temporal)\"]\n        F1[\"Paula is Principal Engineer&lt;br/&gt;valid: 2024-01-10 to present\"]\n        F2[\"Paula works at Microsoft&lt;br/&gt;valid: 2024-01-10 to present\"]\n    end\n\n    C1 --&gt; F1\n    C1 --&gt; F2\n    F1 --&gt; E1\n    F2 --&gt; E1\n    F2 --&gt; E2\n\n    style C1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style C2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style C3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style E1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E2 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style F1 fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style F2 fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre> <ol> <li>Content - Immutable source documents that serve as evidence</li> <li>Entities - Resolved identities (people, organizations, places)</li> <li>Facts - Temporal assertions with validity periods</li> </ol>"},{"location":"#installation","title":"Installation","text":"<p>Add to your Gemfile:</p> <pre><code>gem 'fact_db'\n</code></pre> <p>Then run:</p> <pre><code>bundle install\n</code></pre> <p>See the Installation Guide for detailed setup instructions.</p>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.0</li> <li>PostgreSQL with pgvector extension</li> <li>Optional: ruby_llm gem for LLM-powered extraction</li> </ul>"},{"location":"#license","title":"License","text":"<p>MIT License - Copyright \u00a9 2025 Dewayne VanHoozer</p>"},{"location":"concepts/","title":"Core Concepts","text":"<p>FactDb is built around several key concepts that work together to provide temporal fact tracking with full provenance.</p>"},{"location":"concepts/#the-three-layer-model","title":"The Three-Layer Model","text":""},{"location":"concepts/#content-layer","title":"Content Layer","text":"<p>The content layer stores immutable source documents - emails, articles, reports, transcripts, or any text that contains facts. Content is:</p> <ul> <li>Immutable - Once ingested, content never changes</li> <li>Deduplicated - Identified by content hash to prevent duplicates</li> <li>Timestamped - Records when the content was captured</li> <li>Searchable - Supports full-text and semantic search via embeddings</li> </ul>"},{"location":"concepts/#entity-layer","title":"Entity Layer","text":"<p>Entities represent real-world things mentioned in content:</p> Type Examples <code>person</code> Paula Chen, John Smith <code>organization</code> Microsoft, Acme Corp <code>place</code> San Francisco, Building A <code>product</code> Windows 11, iPhone <code>event</code> Q4 2024 Earnings Call <p>Entities support:</p> <ul> <li>Canonical Names - The authoritative name for the entity</li> <li>Aliases - Alternative names and spellings</li> <li>Resolution - Matching mentions to entities via exact match, aliases, or fuzzy matching</li> <li>Merging - Combining duplicate entities when discovered</li> </ul>"},{"location":"concepts/#fact-layer","title":"Fact Layer","text":"<p>Facts are temporal assertions about entities:</p> <pre><code># A fact has:\n# - text: The assertion itself\n# - valid_at: When the fact became true\n# - invalid_at: When the fact stopped being true (nil if still valid)\n# - status: canonical, superseded, corroborated, synthesized\n# - entity_mentions: Links to entities mentioned in the fact\n# - fact_sources: Links to source content\n</code></pre>"},{"location":"concepts/#fact-lifecycle","title":"Fact Lifecycle","text":"<p>Facts move through different statuses as information evolves:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; canonical: New fact extracted\n    canonical --&gt; corroborated: Multiple sources confirm\n    canonical --&gt; superseded: New information replaces\n    canonical --&gt; synthesized: Combined with other facts\n    superseded --&gt; [*]: Archived\n    corroborated --&gt; superseded: Later replaced\n\n    classDef blue fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    classDef green fill:#047857,stroke:#065F46,color:#FFFFFF\n    classDef red fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    classDef yellow fill:#B45309,stroke:#92400E,color:#FFFFFF\n\n    class canonical blue\n    class corroborated green\n    class superseded red\n    class synthesized yellow</code></pre>"},{"location":"concepts/#canonical","title":"Canonical","text":"<p>A canonical fact is the current authoritative version:</p> <pre><code>fact = facts.fact_service.create(\n  \"Paula is a Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [{ entity: paula, role: \"subject\" }]\n)\n# fact.status =&gt; \"canonical\"\n</code></pre>"},{"location":"concepts/#superseded","title":"Superseded","text":"<p>When information changes, the old fact is superseded:</p> <pre><code># Paula gets promoted\nnew_fact = facts.fact_service.resolver.supersede(\n  fact.id,\n  \"Paula is a Senior Principal Engineer\",\n  valid_at: Date.parse(\"2024-06-01\")\n)\n# old fact.status =&gt; \"superseded\"\n# old fact.invalid_at =&gt; \"2024-06-01\"\n# new_fact.status =&gt; \"canonical\"\n</code></pre>"},{"location":"concepts/#corroborated","title":"Corroborated","text":"<p>Facts confirmed by multiple sources gain higher confidence:</p> <pre><code>facts.fact_service.resolver.corroborate(fact.id, other_fact.id)\n# After 2+ corroborations: fact.status =&gt; \"corroborated\"\n</code></pre>"},{"location":"concepts/#synthesized","title":"Synthesized","text":"<p>Derived facts combine information from multiple sources:</p> <pre><code>synthesized = facts.fact_service.resolver.synthesize(\n  [fact1.id, fact2.id, fact3.id],\n  \"Paula worked at Microsoft from Jan 2024, promoted to Senior in June 2024\",\n  valid_at: Date.parse(\"2024-01-10\")\n)\n# synthesized.status =&gt; \"synthesized\"\n# synthesized.derived_from_ids =&gt; [fact1.id, fact2.id, fact3.id]\n</code></pre>"},{"location":"concepts/#temporal-queries","title":"Temporal Queries","text":"<p>The power of FactDb is querying facts across time:</p> <pre><code># What do we know now?\ncurrent_facts = facts.query_facts(entity: paula.id)\n\n# What did we know on March 1st?\nmarch_facts = facts.facts_at(Date.parse(\"2024-03-01\"), entity: paula.id)\n\n# What's the full timeline?\ntimeline = facts.timeline_for(paula.id, from: \"2024-01-01\", to: \"2024-12-31\")\n</code></pre>"},{"location":"concepts/#entity-resolution","title":"Entity Resolution","text":"<p>When extracting facts, mentions must be resolved to entities:</p> <pre><code>graph LR\n    M1[\"'Paula'\"] --&gt; R{Resolver}\n    M2[\"'P. Chen'\"] --&gt; R\n    M3[\"'Paula Chen'\"] --&gt; R\n    R --&gt; E[Paula Chen Entity]\n\n    style M1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style M2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style M3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style R fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style E fill:#047857,stroke:#065F46,color:#FFFFFF</code></pre> <p>Resolution strategies (in order):</p> <ol> <li>Exact Match - Direct canonical name match</li> <li>Alias Match - Match against registered aliases</li> <li>Fuzzy Match - Levenshtein distance for typos/variations</li> <li>Create New - If no match, optionally create new entity</li> </ol>"},{"location":"concepts/#audit-trails","title":"Audit Trails","text":"<p>Every fact maintains links to its source:</p> <pre><code>fact.fact_sources.each do |fact_source|\n  puts \"Source: #{fact_source.source.title}\"\n  puts \"Type: #{fact_source.source_type}\"  # primary, supporting, contradicting\n  puts \"Excerpt: #{fact_source.excerpt}\"\n  puts \"Confidence: #{fact_source.confidence}\"\nend\n</code></pre> <p>This enables:</p> <ul> <li>Tracing facts back to original documents</li> <li>Verifying information</li> <li>Understanding confidence levels</li> <li>Investigating contradictions</li> </ul>"},{"location":"api/","title":"API Reference","text":"<p>Complete API documentation for FactDb.</p>"},{"location":"api/#main-classes","title":"Main Classes","text":"<ul> <li>Facts - Main interface for FactDb operations</li> </ul>"},{"location":"api/#models","title":"Models","text":"<ul> <li>Source - Immutable source content</li> <li>Entity - Resolved identities</li> <li>Fact - Temporal assertions</li> </ul>"},{"location":"api/#services","title":"Services","text":"<ul> <li>SourceService - Ingest and manage sources</li> <li>EntityService - Create and resolve entities</li> <li>FactService - Extract and query facts</li> </ul>"},{"location":"api/#extractors","title":"Extractors","text":"<ul> <li>ManualExtractor - API-driven extraction</li> <li>LLMExtractor - AI-powered extraction</li> <li>RuleBasedExtractor - Pattern matching</li> </ul>"},{"location":"api/#pipeline","title":"Pipeline","text":"<ul> <li>ExtractionPipeline - Concurrent extraction</li> <li>ResolutionPipeline - Parallel resolution</li> </ul>"},{"location":"api/#module-structure","title":"Module Structure","text":"<pre><code>FactDb\n\u251c\u2500\u2500 Facts                    # Main class\n\u251c\u2500\u2500 Config                   # Configuration\n\u251c\u2500\u2500 Database                 # Database connection\n\u251c\u2500\u2500 Models\n\u2502   \u251c\u2500\u2500 Source\n\u2502   \u251c\u2500\u2500 Entity\n\u2502   \u251c\u2500\u2500 EntityAlias\n\u2502   \u251c\u2500\u2500 Fact\n\u2502   \u251c\u2500\u2500 EntityMention\n\u2502   \u2514\u2500\u2500 FactSource\n\u251c\u2500\u2500 Services\n\u2502   \u251c\u2500\u2500 SourceService\n\u2502   \u251c\u2500\u2500 EntityService\n\u2502   \u2514\u2500\u2500 FactService\n\u251c\u2500\u2500 Extractors\n\u2502   \u251c\u2500\u2500 Base\n\u2502   \u251c\u2500\u2500 ManualExtractor\n\u2502   \u251c\u2500\u2500 LLMExtractor\n\u2502   \u2514\u2500\u2500 RuleBasedExtractor\n\u251c\u2500\u2500 Resolution\n\u2502   \u251c\u2500\u2500 EntityResolver\n\u2502   \u2514\u2500\u2500 FactResolver\n\u251c\u2500\u2500 Pipeline\n\u2502   \u251c\u2500\u2500 ExtractionPipeline\n\u2502   \u2514\u2500\u2500 ResolutionPipeline\n\u251c\u2500\u2500 Temporal\n\u2502   \u251c\u2500\u2500 Query\n\u2502   \u2514\u2500\u2500 Timeline\n\u2514\u2500\u2500 LLM\n    \u2514\u2500\u2500 Adapter\n</code></pre>"},{"location":"api/facts/","title":"Facts","text":"<p>The main interface for FactDb operations.</p>"},{"location":"api/facts/#class-factdbfacts","title":"Class: <code>FactDb::Facts</code>","text":"<pre><code>facts = FactDb.new\n# or\nfacts = FactDb::Facts.new(config: custom_config)\n</code></pre>"},{"location":"api/facts/#attributes","title":"Attributes","text":"Attribute Type Description <code>config</code> Config Configuration instance <code>source_service</code> SourceService Service for source operations <code>entity_service</code> EntityService Service for entity operations <code>fact_service</code> FactService Service for fact operations <code>extraction_pipeline</code> ExtractionPipeline Pipeline for batch extraction <code>resolution_pipeline</code> ResolutionPipeline Pipeline for batch resolution"},{"location":"api/facts/#methods","title":"Methods","text":""},{"location":"api/facts/#initialize","title":"initialize","text":"<pre><code>def initialize(config: nil)\n</code></pre> <p>Create a new Facts instance.</p> <p>Parameters:</p> <ul> <li><code>config</code> (Config, optional) - Configuration instance. Uses <code>FactDb.config</code> if not provided.</li> </ul> <p>Example:</p> <pre><code># Use default configuration\nfacts = FactDb.new\n\n# Use custom configuration\nconfig = FactDb::Config.new\nconfig.database.url = \"postgresql://localhost/my_db\"\nfacts = FactDb.new(config: config)\n</code></pre>"},{"location":"api/facts/#ingest","title":"ingest","text":"<pre><code>def ingest(content, type:, captured_at: Time.current, metadata: {}, title: nil, source_uri: nil)\n</code></pre> <p>Ingest raw content into the fact database.</p> <p>Parameters:</p> <ul> <li><code>content</code> (String) - The source text content</li> <li><code>type</code> (Symbol) - Content type (:email, :document, :article, etc.)</li> <li><code>captured_at</code> (Time, optional) - When content was captured</li> <li><code>metadata</code> (Hash, optional) - Additional metadata</li> <li><code>title</code> (String, optional) - Content title</li> <li><code>source_uri</code> (String, optional) - Original location</li> </ul> <p>Returns: <code>Models::Source</code></p> <p>Example:</p> <pre><code>source = facts.ingest(\n  \"Paula joined Microsoft on Jan 10, 2024\",\n  type: :announcement,\n  title: \"New Hire\",\n  captured_at: Time.current\n)\n</code></pre>"},{"location":"api/facts/#extract_facts","title":"extract_facts","text":"<pre><code>def extract_facts(source_id, extractor: @config.default_extractor)\n</code></pre> <p>Extract facts from content.</p> <p>Parameters:</p> <ul> <li><code>source_id</code> (Integer) - Source ID</li> <li><code>extractor</code> (Symbol, optional) - Extraction method (:manual, :llm, :rule_based)</li> </ul> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>extracted = facts.extract_facts(source.id, extractor: :llm)\n</code></pre>"},{"location":"api/facts/#query_facts","title":"query_facts","text":"<pre><code>def query_facts(topic: nil, at: nil, entity: nil, status: :canonical)\n</code></pre> <p>Query facts with temporal and entity filtering.</p> <p>Parameters:</p> <ul> <li><code>topic</code> (String, optional) - Text search query</li> <li><code>at</code> (Date/Time, optional) - Point in time (nil = current)</li> <li><code>entity</code> (Integer, optional) - Entity ID filter</li> <li><code>status</code> (Symbol, optional) - Fact status filter</li> </ul> <p>Returns: <code>ActiveRecord::Relation&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code># Current facts about Paula\nresults = facts.query_facts(entity: paula.id)\n\n# Facts on a topic\nresults = facts.query_facts(topic: \"engineering\")\n\n# Historical query\nresults = facts.query_facts(at: Date.parse(\"2023-06-15\"))\n</code></pre>"},{"location":"api/facts/#resolve_entity","title":"resolve_entity","text":"<pre><code>def resolve_entity(name, type: nil)\n</code></pre> <p>Resolve a name to an entity.</p> <p>Parameters:</p> <ul> <li><code>name</code> (String) - Name to resolve</li> <li><code>type</code> (Symbol, optional) - Entity type filter</li> </ul> <p>Returns: <code>Models::Entity</code> or <code>nil</code></p> <p>Example:</p> <pre><code>entity = facts.resolve_entity(\"Paula Chen\", type: :person)\n</code></pre>"},{"location":"api/facts/#timeline_for","title":"timeline_for","text":"<pre><code>def timeline_for(entity_id, from: nil, to: nil)\n</code></pre> <p>Build a timeline for an entity.</p> <p>Parameters:</p> <ul> <li><code>entity_id</code> (Integer) - Entity ID</li> <li><code>from</code> (Date/Time, optional) - Start of range</li> <li><code>to</code> (Date/Time, optional) - End of range</li> </ul> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>timeline = facts.timeline_for(paula.id, from: \"2023-01-01\", to: \"2024-12-31\")\n</code></pre>"},{"location":"api/facts/#current_facts_for","title":"current_facts_for","text":"<pre><code>def current_facts_for(entity_id)\n</code></pre> <p>Get currently valid facts about an entity.</p> <p>Parameters:</p> <ul> <li><code>entity_id</code> (Integer) - Entity ID</li> </ul> <p>Returns: <code>ActiveRecord::Relation&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>current = facts.current_facts_for(paula.id)\n</code></pre>"},{"location":"api/facts/#facts_at","title":"facts_at","text":"<pre><code>def facts_at(at, entity: nil, topic: nil)\n</code></pre> <p>Get facts valid at a specific point in time.</p> <p>Parameters:</p> <ul> <li><code>at</code> (Date/Time) - Point in time</li> <li><code>entity</code> (Integer, optional) - Entity ID filter</li> <li><code>topic</code> (String, optional) - Text search query</li> </ul> <p>Returns: <code>ActiveRecord::Relation&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>historical = facts.facts_at(Date.parse(\"2023-06-15\"), entity: paula.id)\n</code></pre>"},{"location":"api/facts/#batch_extract","title":"batch_extract","text":"<pre><code>def batch_extract(source_ids, extractor: @config.default_extractor, parallel: true)\n</code></pre> <p>Batch extract facts from multiple content items.</p> <p>Parameters:</p> <ul> <li><code>source_ids</code> (Array) - Source IDs to process <li><code>extractor</code> (Symbol, optional) - Extraction method</li> <li><code>parallel</code> (Boolean, optional) - Use parallel processing (default: true)</li> <p>Returns: <code>Array&lt;Hash&gt;</code> - Results per content</p> <p>Example:</p> <pre><code>results = facts.batch_extract([s1.id, s2.id, s3.id], parallel: true)\nresults.each do |r|\n  puts \"#{r[:source_id]}: #{r[:facts].count} facts\"\nend\n</code></pre>"},{"location":"api/facts/#batch_resolve_entities","title":"batch_resolve_entities","text":"<pre><code>def batch_resolve_entities(names, type: nil)\n</code></pre> <p>Batch resolve entity names.</p> <p>Parameters:</p> <ul> <li><code>names</code> (Array) - Names to resolve <li><code>type</code> (Symbol, optional) - Entity type filter</li> <p>Returns: <code>Array&lt;Hash&gt;</code> - Resolution results</p> <p>Example:</p> <pre><code>results = facts.batch_resolve_entities([\"Paula\", \"Microsoft\"])\n</code></pre>"},{"location":"api/facts/#detect_fact_conflicts","title":"detect_fact_conflicts","text":"<pre><code>def detect_fact_conflicts(entity_ids)\n</code></pre> <p>Detect fact conflicts for multiple entities.</p> <p>Parameters:</p> <ul> <li><code>entity_ids</code> (Array) - Entity IDs to check <p>Returns: <code>Array&lt;Hash&gt;</code> - Conflict detection results</p> <p>Example:</p> <pre><code>conflicts = facts.detect_fact_conflicts([paula.id, john.id])\n</code></pre>"},{"location":"api/extractors/","title":"Extractors","text":"<p>Extractors are responsible for identifying and creating facts from source content.</p>"},{"location":"api/extractors/#available-extractors","title":"Available Extractors","text":"<ul> <li>ManualExtractor - API-driven fact creation</li> <li>LLMExtractor - AI-powered extraction</li> <li>RuleBasedExtractor - Pattern matching</li> </ul>"},{"location":"api/extractors/#base-class","title":"Base Class","text":"<p>All extractors inherit from <code>FactDb::Extractors::Base</code>:</p> <pre><code>class Base\n  attr_reader :config\n\n  def initialize(config = FactDb.config)\n    @config = config\n  end\n\n  def extract(content)\n    raise NotImplementedError\n  end\n\n  def extraction_method\n    self.class.name.split(\"::\").last.sub(\"Extractor\", \"\").underscore\n  end\nend\n</code></pre>"},{"location":"api/extractors/#creating-custom-extractors","title":"Creating Custom Extractors","text":"<pre><code>class MyExtractor &lt; FactDb::Extractors::Base\n  def extract(source)\n    facts = []\n\n    # Your extraction logic\n    # Parse source.content\n    # Create fact records\n\n    facts\n  end\nend\n</code></pre>"},{"location":"api/extractors/#using-extractors","title":"Using Extractors","text":""},{"location":"api/extractors/#via-factdb","title":"Via FactDb","text":"<pre><code>facts = FactDb.new\nextracted = facts.extract_facts(source.id, extractor: :llm)\n</code></pre>"},{"location":"api/extractors/#directly","title":"Directly","text":"<pre><code>extractor = FactDb::Extractors::LLMExtractor.new(config)\nfacts = extractor.extract(source)\n</code></pre>"},{"location":"api/extractors/#extractor-selection","title":"Extractor Selection","text":"Extractor Best For Accuracy Speed Manual High-stakes facts Highest Slowest LLM Complex documents High Medium Rule-based Structured content Medium Fastest"},{"location":"api/extractors/llm/","title":"LLMExtractor","text":"<p>AI-powered fact extraction using large language models.</p>"},{"location":"api/extractors/llm/#class-factdbextractorsllmextractor","title":"Class: <code>FactDb::Extractors::LLMExtractor</code>","text":"<pre><code>extractor = FactDb::Extractors::LLMExtractor.new(config)\n</code></pre>"},{"location":"api/extractors/llm/#requirements","title":"Requirements","text":"<ul> <li><code>ruby_llm</code> gem installed</li> <li>LLM provider configured (API key, model)</li> </ul>"},{"location":"api/extractors/llm/#configuration","title":"Configuration","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :openai\n  config.llm.model = \"gpt-4o-mini\"\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n</code></pre>"},{"location":"api/extractors/llm/#methods","title":"Methods","text":""},{"location":"api/extractors/llm/#extract","title":"extract","text":"<pre><code>def extract(content)\n</code></pre> <p>Extract facts from content using LLM.</p> <p>Parameters:</p> <ul> <li><code>source</code> (Models::Source) - Source to process</li> </ul> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>extractor = LLMExtractor.new(config)\nfacts = extractor.extract(source)\n\nfacts.each do |fact|\n  puts fact.text\n  puts \"  Valid: #{fact.valid_at}\"\n  puts \"  Confidence: #{fact.confidence}\"\nend\n</code></pre>"},{"location":"api/extractors/llm/#extraction-process","title":"Extraction Process","text":"<ol> <li>Prompt Construction - Build prompt with content text</li> <li>LLM Call - Send to configured LLM provider</li> <li>Response Parsing - Parse JSON response</li> <li>Fact Creation - Create fact records</li> <li>Entity Resolution - Resolve mentioned entities</li> <li>Source Linking - Link facts to source content</li> </ol>"},{"location":"api/extractors/llm/#prompt-structure","title":"Prompt Structure","text":"<p>The extractor uses a structured prompt:</p> <pre><code>Extract temporal facts from this content. For each fact:\n1. Identify the assertion (what is being stated)\n2. Identify entities mentioned (people, organizations, places)\n3. Determine when the fact became valid\n4. Assess confidence level\n\nContent:\n{source.content}\n\nReturn JSON:\n{\n  \"facts\": [\n    {\n      \"text\": \"...\",\n      \"valid_at\": \"YYYY-MM-DD\",\n      \"entities\": [\n        {\"name\": \"...\", \"type\": \"person|organization|place\", \"role\": \"subject|object|...\"}\n      ],\n      \"confidence\": 0.0-1.0\n    }\n  ]\n}\n</code></pre>"},{"location":"api/extractors/llm/#supported-providers","title":"Supported Providers","text":"Provider Models Config OpenAI gpt-4o, gpt-4o-mini <code>llm.provider = :openai</code> Anthropic claude-sonnet-4, claude-3-haiku <code>llm.provider = :anthropic</code> Google gemini-2.0-flash <code>llm.provider = :gemini</code> Ollama llama3.2, mistral <code>llm.provider = :ollama</code> AWS Bedrock claude-sonnet-4 <code>llm.provider = :bedrock</code> OpenRouter Various <code>llm.provider = :openrouter</code>"},{"location":"api/extractors/llm/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  facts = extractor.extract(content)\nrescue FactDb::ConfigurationError =&gt; e\n  # LLM not configured\n  puts \"Config error: #{e.message}\"\nrescue FactDb::ExtractionError =&gt; e\n  # Extraction failed\n  puts \"Extraction error: #{e.message}\"\nend\n</code></pre>"},{"location":"api/extractors/llm/#advantages","title":"Advantages","text":"<ul> <li>Handles unstructured text</li> <li>Understands context and nuance</li> <li>Identifies implicit facts</li> <li>Resolves entities automatically</li> </ul>"},{"location":"api/extractors/llm/#disadvantages","title":"Disadvantages","text":"<ul> <li>API costs</li> <li>Latency</li> <li>Occasional errors</li> <li>Requires validation</li> </ul>"},{"location":"api/extractors/llm/#best-practices","title":"Best Practices","text":""},{"location":"api/extractors/llm/#1-validate-results","title":"1. Validate Results","text":"<pre><code>facts = extractor.extract(source)\nfacts.each do |fact|\n  if fact.confidence &lt; 0.7\n    fact.update!(metadata: { needs_review: true })\n  end\nend\n</code></pre>"},{"location":"api/extractors/llm/#2-cache-responses","title":"2. Cache Responses","text":"<pre><code>cache_key = \"llm:#{source.content_hash}\"\nfacts = Rails.cache.fetch(cache_key) do\n  extractor.extract(source)\nend\n</code></pre>"},{"location":"api/extractors/llm/#3-handle-rate-limits","title":"3. Handle Rate Limits","text":"<pre><code>require 'retryable'\n\nRetryable.retryable(tries: 3, sleep: lambda { |n| 2**n }) do\n  extractor.extract(source)\nend\n</code></pre>"},{"location":"api/extractors/manual/","title":"ManualExtractor","text":"<p>API-driven fact creation for maximum control and accuracy.</p>"},{"location":"api/extractors/manual/#class-factdbextractorsmanualextractor","title":"Class: <code>FactDb::Extractors::ManualExtractor</code>","text":"<p>The ManualExtractor doesn't automatically extract facts - instead it provides a structured interface for creating facts programmatically.</p>"},{"location":"api/extractors/manual/#usage","title":"Usage","text":"<pre><code>extractor = FactDb::Extractors::ManualExtractor.new(config)\n</code></pre>"},{"location":"api/extractors/manual/#methods","title":"Methods","text":""},{"location":"api/extractors/manual/#extract","title":"extract","text":"<pre><code>def extract(content)\n</code></pre> <p>Returns an empty array - manual extraction is done via direct fact creation.</p> <p>Returns: <code>[]</code></p>"},{"location":"api/extractors/manual/#when-to-use","title":"When to Use","text":"<ul> <li>High-stakes facts that require human verification</li> <li>Structured data import from external systems</li> <li>Fact correction or adjustment</li> <li>Initial seeding of the system</li> </ul>"},{"location":"api/extractors/manual/#creating-facts-manually","title":"Creating Facts Manually","text":"<p>Instead of using the extractor, create facts directly:</p> <pre><code>facts = FactDb.new\n\n# Create entities\npaula = facts.entity_service.create(\"Paula Chen\", type: :person)\nmicrosoft = facts.entity_service.create(\"Microsoft\", type: :organization)\n\n# Create fact with explicit links\nfact = facts.fact_service.create(\n  \"Paula Chen joined Microsoft as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: microsoft, role: \"organization\", text: \"Microsoft\" }\n  ],\n  sources: [\n    { content: announcement, type: \"primary\", excerpt: \"...accepted the offer...\" }\n  ],\n  confidence: 1.0\n)\n</code></pre>"},{"location":"api/extractors/manual/#bulk-import-pattern","title":"Bulk Import Pattern","text":"<pre><code># Import from structured data\ndata = [\n  { text: \"Fact 1\", date: \"2024-01-01\", entity: \"Paula\" },\n  { text: \"Fact 2\", date: \"2024-01-15\", entity: \"Paula\" }\n]\n\ndata.each do |item|\n  entity = facts.resolve_entity(item[:entity])\n\n  facts.fact_service.create(\n    item[:text],\n    valid_at: Date.parse(item[:date]),\n    mentions: [{ entity: entity, role: \"subject\", text: item[:entity] }],\n    extraction_method: \"manual\"\n  )\nend\n</code></pre>"},{"location":"api/extractors/manual/#advantages","title":"Advantages","text":"<ul> <li>Complete control over fact creation</li> <li>Highest accuracy (human-verified)</li> <li>No LLM costs</li> <li>Works without external dependencies</li> </ul>"},{"location":"api/extractors/manual/#disadvantages","title":"Disadvantages","text":"<ul> <li>Labor intensive</li> <li>Not scalable for large volumes</li> <li>Requires domain expertise</li> </ul>"},{"location":"api/extractors/rule-based/","title":"RuleBasedExtractor","text":"<p>Pattern-based fact extraction using regular expressions.</p>"},{"location":"api/extractors/rule-based/#class-factdbextractorsrulebasedextractor","title":"Class: <code>FactDb::Extractors::RuleBasedExtractor</code>","text":"<pre><code>extractor = FactDb::Extractors::RuleBasedExtractor.new(config)\n</code></pre>"},{"location":"api/extractors/rule-based/#methods","title":"Methods","text":""},{"location":"api/extractors/rule-based/#extract","title":"extract","text":"<pre><code>def extract(content)\n</code></pre> <p>Extract facts using pattern matching.</p> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p>"},{"location":"api/extractors/rule-based/#built-in-patterns","title":"Built-in Patterns","text":"<p>The extractor includes patterns for common fact types:</p>"},{"location":"api/extractors/rule-based/#employment-events","title":"Employment Events","text":"<pre><code># \"X joined Y\"\n/(?&lt;person&gt;\\w+(?:\\s+\\w+)*)\\s+joined\\s+(?&lt;org&gt;\\w+(?:\\s+\\w+)*)/i\n\n# \"X left Y\"\n/(?&lt;person&gt;\\w+(?:\\s+\\w+)*)\\s+left\\s+(?&lt;org&gt;\\w+(?:\\s+\\w+)*)/i\n\n# \"X was hired by Y\"\n/(?&lt;person&gt;\\w+(?:\\s+\\w+)*)\\s+was\\s+hired\\s+by\\s+(?&lt;org&gt;\\w+(?:\\s+\\w+)*)/i\n</code></pre>"},{"location":"api/extractors/rule-based/#title-changes","title":"Title Changes","text":"<pre><code># \"X is/was the Y\"\n/(?&lt;person&gt;\\w+(?:\\s+\\w+)*)\\s+(?:is|was)\\s+(?:the\\s+)?(?&lt;title&gt;[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)/\n\n# \"X promoted to Y\"\n/(?&lt;person&gt;\\w+(?:\\s+\\w+)*)\\s+(?:was\\s+)?promoted\\s+to\\s+(?&lt;title&gt;[A-Z][a-z]+(?:\\s+[A-Z][a-z]+)*)/i\n</code></pre>"},{"location":"api/extractors/rule-based/#date-patterns","title":"Date Patterns","text":"<pre><code># \"on January 10, 2024\"\n/on\\s+(?&lt;month&gt;\\w+)\\s+(?&lt;day&gt;\\d{1,2}),?\\s+(?&lt;year&gt;\\d{4})/i\n\n# \"in Q4 2024\"\n/in\\s+Q(?&lt;quarter&gt;\\d)\\s+(?&lt;year&gt;\\d{4})/i\n\n# ISO dates\n/(?&lt;date&gt;\\d{4}-\\d{2}-\\d{2})/\n</code></pre>"},{"location":"api/extractors/rule-based/#usage-example","title":"Usage Example","text":"<pre><code>extractor = RuleBasedExtractor.new(config)\n\nsource = Models::Source.create!(\n  content: \"Paula Chen joined Microsoft on January 10, 2024 as Principal Engineer.\",\n  type: \"announcement\",\n  captured_at: Time.current\n)\n\nfacts = extractor.extract(source)\n# Returns facts about:\n# - Paula joining Microsoft\n# - Paula's title as Principal Engineer\n# - Date: January 10, 2024\n</code></pre>"},{"location":"api/extractors/rule-based/#adding-custom-patterns","title":"Adding Custom Patterns","text":"<p>Extend the extractor with custom patterns:</p> <pre><code>class CustomRuleExtractor &lt; FactDb::Extractors::RuleBasedExtractor\n  CUSTOM_PATTERNS = [\n    {\n      pattern: /revenue\\s+of\\s+\\$(?&lt;amount&gt;[\\d,]+)/i,\n      type: :financial,\n      handler: :extract_revenue\n    }\n  ]\n\n  def extract(content)\n    facts = super(content)\n    facts + extract_custom_patterns(content)\n  end\n\n  private\n\n  def extract_custom_patterns(source)\n    facts = []\n    CUSTOM_PATTERNS.each do |rule|\n      source.content.scan(rule[:pattern]) do |match|\n        facts &lt;&lt; send(rule[:handler], match, source)\n      end\n    end\n    facts\n  end\n\n  def extract_revenue(match, source)\n    Models::Fact.create!(\n      text: \"Revenue of $#{match[:amount]}\",\n      valid_at: source.captured_at,\n      extraction_method: \"rule_based\",\n      # ...\n    )\n  end\nend\n</code></pre>"},{"location":"api/extractors/rule-based/#advantages","title":"Advantages","text":"<ul> <li>Fast execution</li> <li>No external dependencies</li> <li>Predictable results</li> <li>Works offline</li> <li>Zero cost</li> </ul>"},{"location":"api/extractors/rule-based/#disadvantages","title":"Disadvantages","text":"<ul> <li>Limited to defined patterns</li> <li>Misses implicit facts</li> <li>Requires pattern maintenance</li> <li>May produce false positives</li> </ul>"},{"location":"api/extractors/rule-based/#best-practices","title":"Best Practices","text":""},{"location":"api/extractors/rule-based/#1-combine-with-llm","title":"1. Combine with LLM","text":"<pre><code># Use rule-based for structured content\nif content.type == \"form\"\n  facts = rule_extractor.extract(content)\nelse\n  facts = llm_extractor.extract(content)\nend\n</code></pre>"},{"location":"api/extractors/rule-based/#2-validate-matches","title":"2. Validate Matches","text":"<pre><code>facts = extractor.extract(content)\nfacts.select { |f| f.confidence &gt; 0.8 }\n</code></pre>"},{"location":"api/extractors/rule-based/#3-log-unmatched-sources","title":"3. Log Unmatched Sources","text":"<pre><code>facts = extractor.extract(source)\nif facts.empty?\n  logger.info \"No patterns matched for source #{source.id}\"\nend\n</code></pre>"},{"location":"api/models/","title":"Models","text":"<p>FactDb uses ActiveRecord models for data persistence.</p>"},{"location":"api/models/#core-models","title":"Core Models","text":"<ul> <li>Source - Immutable source content</li> <li>Entity - Resolved identities with aliases</li> <li>Fact - Temporal assertions</li> </ul>"},{"location":"api/models/#supporting-models","title":"Supporting Models","text":""},{"location":"api/models/#entityalias","title":"EntityAlias","text":"<p>Stores alternative names for entities.</p> <pre><code>class EntityAlias &lt; ActiveRecord::Base\n  belongs_to :entity\nend\n</code></pre> Column Type Description entity_id bigint Parent entity name string Alternative name type string Type (nickname, abbreviation, etc.) confidence float Match confidence"},{"location":"api/models/#entitymention","title":"EntityMention","text":"<p>Links facts to mentioned entities.</p> <pre><code>class EntityMention &lt; ActiveRecord::Base\n  belongs_to :fact\n  belongs_to :entity\nend\n</code></pre> Column Type Description fact_id bigint Parent fact entity_id bigint Referenced entity mention_text string How entity was mentioned mention_role string Role (subject, object, etc.) confidence float Resolution confidence"},{"location":"api/models/#factsource","title":"FactSource","text":"<p>Links facts to source content.</p> <pre><code>class FactSource &lt; ActiveRecord::Base\n  belongs_to :fact\n  belongs_to :source\nend\n</code></pre> Column Type Description fact_id bigint Parent fact source_id bigint Source content source_type string Type (primary, supporting, contradicting) excerpt text Relevant text excerpt confidence float Source confidence"},{"location":"api/models/#model-relationships","title":"Model Relationships","text":"<pre><code>erDiagram\n    Source ||--o{ FactSource : \"sourced by\"\n    Entity ||--o{ EntityAlias : \"has\"\n    Entity ||--o{ EntityMention : \"mentioned in\"\n    Fact ||--o{ EntityMention : \"mentions\"\n    Fact ||--o{ FactSource : \"sourced from\"</code></pre>"},{"location":"api/models/entity/","title":"Entity Model","text":"<p>Stores resolved identities (people, organizations, places, etc.).</p>"},{"location":"api/models/entity/#class-factdbmodelsentity","title":"Class: <code>FactDb::Models::Entity</code>","text":"<pre><code>entity = FactDb::Models::Entity.new(\n  name: \"Paula Chen\",\n  type: \"person\"\n)\n</code></pre>"},{"location":"api/models/entity/#attributes","title":"Attributes","text":"Attribute Type Description <code>id</code> Integer Primary key <code>name</code> String Authoritative name <code>type</code> String Type (person, organization, place, etc.) <code>resolution_status</code> String Status (unresolved, resolved, merged) <code>canonical_id</code> Integer Points to canonical entity if merged <code>metadata</code> Hash Additional attributes (JSONB) <code>embedding</code> Vector Semantic search vector <code>created_at</code> DateTime Record creation time"},{"location":"api/models/entity/#entity-types","title":"Entity Types","text":"<ul> <li><code>person</code> - Individual people</li> <li><code>organization</code> - Companies, teams, groups</li> <li><code>place</code> - Locations</li> <li><code>product</code> - Products, services</li> <li><code>event</code> - Named events</li> </ul>"},{"location":"api/models/entity/#resolution-status","title":"Resolution Status","text":"<ul> <li><code>unresolved</code> - Entity created but not confirmed</li> <li><code>resolved</code> - Entity identity confirmed</li> <li><code>merged</code> - Entity merged into another</li> </ul>"},{"location":"api/models/entity/#associations","title":"Associations","text":"<pre><code>has_many :entity_aliases, dependent: :destroy\nhas_many :entity_mentions\nhas_many :facts, through: :entity_mentions\nbelongs_to :merged_into, class_name: 'Entity', optional: true\n</code></pre>"},{"location":"api/models/entity/#instance-methods","title":"Instance Methods","text":""},{"location":"api/models/entity/#add_alias","title":"add_alias","text":"<pre><code>def add_alias(text, type: nil, confidence: 1.0)\n</code></pre> <p>Add an alias to the entity.</p> <p>Example:</p> <pre><code>entity.add_alias(\"Paula\", type: \"nickname\", confidence: 0.95)\n</code></pre>"},{"location":"api/models/entity/#merged","title":"merged?","text":"<pre><code>def merged?\n</code></pre> <p>Returns true if entity has been merged into another.</p>"},{"location":"api/models/entity/#canonical","title":"canonical","text":"<pre><code>def canonical\n</code></pre> <p>Returns the canonical entity (follows merge chain).</p> <p>Example:</p> <pre><code># If entity was merged\ncanonical = entity.canonical  # Returns the canonical entity\n</code></pre>"},{"location":"api/models/entity/#scopes","title":"Scopes","text":""},{"location":"api/models/entity/#by_type","title":"by_type","text":"<pre><code>scope :by_type, -&gt;(t) { where(type: t) }\n</code></pre> <p>Filter by entity type.</p> <pre><code>Entity.by_type('person')\n</code></pre>"},{"location":"api/models/entity/#active","title":"active","text":"<pre><code>scope :active, -&gt; { where.not(resolution_status: 'merged') }\n</code></pre> <p>Exclude merged entities.</p> <pre><code>Entity.active\n</code></pre>"},{"location":"api/models/entity/#resolved","title":"resolved","text":"<pre><code>scope :resolved, -&gt; { where(resolution_status: 'resolved') }\n</code></pre> <p>Only resolved entities.</p>"},{"location":"api/models/entity/#search_name","title":"search_name","text":"<pre><code>scope :search_name, -&gt;(query) {\n  where(\"name ILIKE ?\", \"%#{query}%\")\n}\n</code></pre> <p>Search by name.</p> <pre><code>Entity.search_name(\"paula\")\n</code></pre>"},{"location":"api/models/entity/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/entity/#create-entity","title":"Create Entity","text":"<pre><code>entity = Entity.create!(\n  name: \"Paula Chen\",\n  type: \"person\",\n  metadata: {\n    department: \"Engineering\",\n    employee_id: \"E12345\"\n  }\n)\n</code></pre>"},{"location":"api/models/entity/#add-aliases","title":"Add Aliases","text":"<pre><code>entity.add_alias(\"Paula\")\nentity.add_alias(\"P. Chen\", type: \"abbreviation\")\nentity.add_alias(\"Chen, Paula\", type: \"formal\")\n</code></pre>"},{"location":"api/models/entity/#check-aliases","title":"Check Aliases","text":"<pre><code>entity.entity_aliases.each do |a|\n  puts \"#{a.name} (#{a.type})\"\nend\n</code></pre>"},{"location":"api/models/entity/#get-related-facts","title":"Get Related Facts","text":"<pre><code>entity.facts.each do |fact|\n  puts \"#{fact.valid_at}: #{fact.text}\"\nend\n</code></pre>"},{"location":"api/models/entity/#find-similar-entities","title":"Find Similar Entities","text":"<pre><code># By name\nsimilar = Entity.search_name(\"Microsoft\")\n\n# By embedding\nsimilar = Entity\n  .where.not(embedding: nil)\n  .order(Arel.sql(\"embedding &lt;=&gt; '#{query_embedding}'\"))\n  .limit(10)\n</code></pre>"},{"location":"api/models/entity/#merge-entities","title":"Merge Entities","text":"<pre><code># entity2 will be merged into entity1\nentity2.update!(\n  resolution_status: 'merged',\n  canonical_id: entity1.id\n)\n\n# Copy aliases\nentity2.entity_aliases.each do |a|\n  entity1.add_alias(a.name, type: a.type)\nend\n</code></pre>"},{"location":"api/models/fact/","title":"Fact Model","text":"<p>Stores temporal assertions about entities.</p>"},{"location":"api/models/fact/#class-factdbmodelsfact","title":"Class: <code>FactDb::Models::Fact</code>","text":"<pre><code>fact = FactDb::Models::Fact.new(\n  text: \"Paula Chen is Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  status: \"canonical\"\n)\n</code></pre>"},{"location":"api/models/fact/#attributes","title":"Attributes","text":"Attribute Type Description <code>id</code> Integer Primary key <code>text</code> Text The assertion <code>digest</code> String SHA256 digest for deduplication <code>valid_at</code> DateTime When fact became true <code>invalid_at</code> DateTime When fact stopped being true (nil if current) <code>status</code> String Status (canonical, superseded, corroborated, synthesized) <code>superseded_by_id</code> Integer Points to replacing fact <code>derived_from_ids</code> Array Source facts for synthesized <code>corroborated_by_ids</code> Array Corroborating facts <code>confidence</code> Float Extraction confidence (0.0-1.0) <code>extraction_method</code> String How fact was extracted <code>metadata</code> Hash Additional data (JSONB) <code>embedding</code> Vector Semantic search vector <code>created_at</code> DateTime Record creation time"},{"location":"api/models/fact/#fact-status","title":"Fact Status","text":"<ul> <li><code>canonical</code> - Current authoritative version</li> <li><code>superseded</code> - Replaced by newer information</li> <li><code>corroborated</code> - Confirmed by multiple sources</li> <li><code>synthesized</code> - Derived from multiple facts</li> </ul>"},{"location":"api/models/fact/#associations","title":"Associations","text":"<pre><code>has_many :entity_mentions, dependent: :destroy\nhas_many :entities, through: :entity_mentions\nhas_many :fact_sources, dependent: :destroy\nhas_many :contents, through: :fact_sources\nbelongs_to :superseded_by, class_name: 'Fact', optional: true\n</code></pre>"},{"location":"api/models/fact/#instance-methods","title":"Instance Methods","text":""},{"location":"api/models/fact/#add_mention","title":"add_mention","text":"<pre><code>def add_mention(entity:, text:, role:, confidence: 1.0)\n</code></pre> <p>Add an entity mention to the fact.</p> <p>Example:</p> <pre><code>fact.add_mention(\n  entity: paula,\n  text: \"Paula Chen\",\n  role: \"subject\",\n  confidence: 0.95\n)\n</code></pre>"},{"location":"api/models/fact/#add_source","title":"add_source","text":"<pre><code>def add_source(content:, type: \"primary\", excerpt: nil, confidence: 1.0)\n</code></pre> <p>Add a source content link.</p> <p>Example:</p> <pre><code>fact.add_source(\n  content: email,\n  type: \"primary\",\n  excerpt: \"...accepted the offer...\"\n)\n</code></pre>"},{"location":"api/models/fact/#currently_valid","title":"currently_valid?","text":"<pre><code>def currently_valid?\n</code></pre> <p>Returns true if fact is currently valid (invalid_at is nil).</p>"},{"location":"api/models/fact/#valid_atdate","title":"valid_at?(date)","text":"<pre><code>def valid_at?(date)\n</code></pre> <p>Returns true if fact was valid at the given date.</p>"},{"location":"api/models/fact/#superseded","title":"superseded?","text":"<pre><code>def superseded?\n</code></pre> <p>Returns true if fact has been superseded.</p>"},{"location":"api/models/fact/#canonical","title":"canonical?","text":"<pre><code>def canonical?\n</code></pre> <p>Returns true if fact is canonical.</p>"},{"location":"api/models/fact/#scopes","title":"Scopes","text":""},{"location":"api/models/fact/#canonical_1","title":"canonical","text":"<pre><code>scope :canonical, -&gt; { where(status: 'canonical') }\n</code></pre> <p>Only canonical facts.</p>"},{"location":"api/models/fact/#currently_valid_1","title":"currently_valid","text":"<pre><code>scope :currently_valid, -&gt; { where(invalid_at: nil) }\n</code></pre> <p>Facts that are currently valid.</p>"},{"location":"api/models/fact/#valid_at","title":"valid_at","text":"<pre><code>scope :valid_at, -&gt;(date) {\n  where(\"valid_at &lt;= ? AND (invalid_at IS NULL OR invalid_at &gt; ?)\", date, date)\n}\n</code></pre> <p>Facts valid at a specific point in time.</p> <pre><code>Fact.valid_at(Date.parse(\"2023-06-15\"))\n</code></pre>"},{"location":"api/models/fact/#mentioning_entity","title":"mentioning_entity","text":"<pre><code>scope :mentioning_entity, -&gt;(entity_id) {\n  joins(:entity_mentions).where(entity_mentions: { entity_id: entity_id })\n}\n</code></pre> <p>Facts mentioning a specific entity.</p> <pre><code>Fact.mentioning_entity(paula.id)\n</code></pre>"},{"location":"api/models/fact/#search_text","title":"search_text","text":"<pre><code>scope :search_text, -&gt;(query) {\n  where(\"text @@ plainto_tsquery(?)\", query)\n}\n</code></pre> <p>Full-text search.</p> <pre><code>Fact.search_text(\"engineer\")\n</code></pre>"},{"location":"api/models/fact/#by_extraction_method","title":"by_extraction_method","text":"<pre><code>scope :by_extraction_method, -&gt;(method) {\n  where(extraction_method: method)\n}\n</code></pre> <p>Filter by extraction method.</p> <pre><code>Fact.by_extraction_method('llm')\n</code></pre>"},{"location":"api/models/fact/#high_confidence","title":"high_confidence","text":"<pre><code>scope :high_confidence, -&gt; { where(\"confidence &gt; 0.8\") }\n</code></pre> <p>High confidence facts only.</p>"},{"location":"api/models/fact/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/fact/#create-fact","title":"Create Fact","text":"<pre><code>fact = Fact.create!(\n  text: \"Paula Chen joined Microsoft as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  status: \"canonical\",\n  extraction_method: \"manual\",\n  confidence: 1.0\n)\n\n# Add mentions\nfact.add_mention(entity: paula, text: \"Paula Chen\", role: \"subject\")\nfact.add_mention(entity: microsoft, text: \"Microsoft\", role: \"organization\")\n\n# Add source\nfact.add_source(content: announcement, type: \"primary\")\n</code></pre>"},{"location":"api/models/fact/#query-facts","title":"Query Facts","text":"<pre><code># Current facts about Paula\nFact.canonical.currently_valid.mentioning_entity(paula.id)\n\n# Historical facts\nFact.valid_at(Date.parse(\"2023-06-15\")).mentioning_entity(paula.id)\n\n# Search\nFact.search_text(\"promoted\")\n</code></pre>"},{"location":"api/models/fact/#supersede-fact","title":"Supersede Fact","text":"<pre><code>new_fact = Fact.create!(\n  text: \"Paula Chen is Senior Principal Engineer\",\n  valid_at: Date.parse(\"2024-06-01\"),\n  status: \"canonical\"\n)\n\nold_fact.update!(\n  status: \"superseded\",\n  superseded_by_id: new_fact.id,\n  invalid_at: Date.parse(\"2024-06-01\")\n)\n</code></pre>"},{"location":"api/models/fact/#get-sources","title":"Get Sources","text":"<pre><code>fact.fact_sources.each do |fact_source|\n  puts \"Source: #{fact_source.source.title}\"\n  puts \"Type: #{fact_source.source_type}\"\n  puts \"Excerpt: #{fact_source.excerpt}\"\nend\n</code></pre>"},{"location":"api/models/fact/#get-mentioned-entities","title":"Get Mentioned Entities","text":"<pre><code>fact.entity_mentions.each do |mention|\n  puts \"#{mention.entity.name} (#{mention.mention_role})\"\nend\n</code></pre>"},{"location":"api/models/source/","title":"Source Model","text":"<p>Stores immutable source content from which facts are extracted.</p>"},{"location":"api/models/source/#class-factdbmodelssource","title":"Class: <code>FactDb::Models::Source</code>","text":"<pre><code>source = FactDb::Models::Source.new(\n  content: \"Document content...\",\n  type: \"email\",\n  captured_at: Time.current\n)\n</code></pre>"},{"location":"api/models/source/#attributes","title":"Attributes","text":"Attribute Type Description <code>id</code> Integer Primary key <code>content_hash</code> String SHA256 hash for deduplication <code>type</code> String Type (email, document, etc.) <code>content</code> Text Original unmodified text content <code>title</code> String Optional title <code>source_uri</code> String Original location <code>metadata</code> Hash Additional metadata (JSONB) <code>embedding</code> Vector Semantic search vector <code>captured_at</code> DateTime When content was captured <code>created_at</code> DateTime Record creation time"},{"location":"api/models/source/#associations","title":"Associations","text":"<pre><code>has_many :fact_sources\nhas_many :facts, through: :fact_sources\n</code></pre>"},{"location":"api/models/source/#callbacks","title":"Callbacks","text":"<pre><code>before_create :compute_hash\nbefore_create :generate_embedding\n</code></pre>"},{"location":"api/models/source/#instance-methods","title":"Instance Methods","text":""},{"location":"api/models/source/#compute_hash","title":"compute_hash","text":"<pre><code>def compute_hash\n</code></pre> <p>Computes SHA256 hash of content for deduplication.</p>"},{"location":"api/models/source/#generate_embedding","title":"generate_embedding","text":"<pre><code>def generate_embedding\n</code></pre> <p>Generates embedding vector using configured generator.</p>"},{"location":"api/models/source/#class-methods","title":"Class Methods","text":""},{"location":"api/models/source/#find_or_create_by_text","title":"find_or_create_by_text","text":"<pre><code>def self.find_or_create_by_text(text, **attributes)\n</code></pre> <p>Find existing source by hash or create new.</p> <p>Example:</p> <pre><code>source = Source.find_or_create_by_text(\n  \"Document text\",\n  type: \"document\",\n  captured_at: Time.current\n)\n</code></pre>"},{"location":"api/models/source/#scopes","title":"Scopes","text":""},{"location":"api/models/source/#by_type","title":"by_type","text":"<pre><code>scope :by_type, -&gt;(type) { where(type: type) }\n</code></pre> <p>Filter by content type.</p> <pre><code>Source.by_type('email')\n</code></pre>"},{"location":"api/models/source/#captured_between","title":"captured_between","text":"<pre><code>scope :captured_between, -&gt;(from, to) {\n  where(captured_at: from..to)\n}\n</code></pre> <p>Filter by capture date range.</p> <pre><code>Source.captured_between(1.week.ago, Time.current)\n</code></pre>"},{"location":"api/models/source/#search_text","title":"search_text","text":"<pre><code>scope :search_text, -&gt;(query) {\n  where(\"content @@ plainto_tsquery(?)\", query)\n}\n</code></pre> <p>Full-text search.</p> <pre><code>Source.search_text(\"quarterly earnings\")\n</code></pre>"},{"location":"api/models/source/#usage-examples","title":"Usage Examples","text":""},{"location":"api/models/source/#create-source","title":"Create Source","text":"<pre><code>source = Source.create!(\n  content: \"Important document...\",\n  type: \"document\",\n  title: \"Q4 Report\",\n  source_uri: \"https://example.com/report.pdf\",\n  captured_at: Time.current,\n  metadata: {\n    author: \"Jane Smith\",\n    department: \"Finance\"\n  }\n)\n</code></pre>"},{"location":"api/models/source/#find-by-hash","title":"Find by Hash","text":"<pre><code>hash = Digest::SHA256.hexdigest(\"Document text\")\nsource = Source.find_by(content_hash: hash)\n</code></pre>"},{"location":"api/models/source/#get-related-facts","title":"Get Related Facts","text":"<pre><code>source.facts.each do |fact|\n  puts fact.text\nend\n</code></pre>"},{"location":"api/models/source/#semantic-search","title":"Semantic Search","text":"<pre><code># Requires embedding\nsimilar = Source\n  .where.not(embedding: nil)\n  .order(Arel.sql(\"embedding &lt;=&gt; '#{query_embedding}'\"))\n  .limit(10)\n</code></pre>"},{"location":"api/pipeline/","title":"Pipeline","text":"<p>Pipelines provide concurrent processing for batch operations using SimpleFlow.</p>"},{"location":"api/pipeline/#available-pipelines","title":"Available Pipelines","text":"<ul> <li>ExtractionPipeline - Concurrent fact extraction</li> <li>ResolutionPipeline - Parallel entity resolution</li> </ul>"},{"location":"api/pipeline/#simpleflow-integration","title":"SimpleFlow Integration","text":"<p>Pipelines are built on the <code>simple_flow</code> gem:</p> <pre><code>require 'simple_flow'\n\npipeline = SimpleFlow::Pipeline.new do\n  step -&gt;(result) { result.continue(transformed_value) }\n  step -&gt;(result) { result.continue(more_transformation) }\nend\n\nresult = pipeline.call(SimpleFlow::Result.new(initial_value))\n</code></pre>"},{"location":"api/pipeline/#pipeline-pattern","title":"Pipeline Pattern","text":"<p>All pipelines follow a common structure:</p> <pre><code>class SomePipeline\n  attr_reader :config\n\n  def initialize(config = FactDb.config)\n    @config = config\n  end\n\n  def process(items, **options)\n    # Sequential processing\n  end\n\n  def process_parallel(items, **options)\n    # Parallel processing\n  end\nend\n</code></pre>"},{"location":"api/pipeline/#result-structure","title":"Result Structure","text":"<p>Pipeline results follow a consistent format:</p> <pre><code>{\n  source_id: 123,           # Item identifier\n  facts: [&lt;Fact&gt;, ...],     # Extracted/resolved items\n  error: nil                # Error message if failed\n}\n</code></pre>"},{"location":"api/pipeline/#error-handling","title":"Error Handling","text":"<p>Pipelines handle errors gracefully:</p> <pre><code>results = pipeline.process_parallel(items)\n\nsuccessful = results.select { |r| r[:error].nil? }\nfailed = results.reject { |r| r[:error].nil? }\n\nfailed.each do |result|\n  logger.error \"Failed: #{result[:error]}\"\nend\n</code></pre>"},{"location":"api/pipeline/extraction/","title":"ExtractionPipeline","text":"<p>Concurrent fact extraction from multiple content items.</p>"},{"location":"api/pipeline/extraction/#class-factdbpipelineextractionpipeline","title":"Class: <code>FactDb::Pipeline::ExtractionPipeline</code>","text":"<pre><code>pipeline = FactDb::Pipeline::ExtractionPipeline.new(config)\n</code></pre>"},{"location":"api/pipeline/extraction/#methods","title":"Methods","text":""},{"location":"api/pipeline/extraction/#process","title":"process","text":"<pre><code>def process(sources, extractor: config.default_extractor)\n</code></pre> <p>Process source items sequentially.</p> <p>Parameters:</p> <ul> <li><code>sources</code> (Array) - Source records</li> <li><code>extractor</code> (Symbol) - Extraction method</li> </ul> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example:</p> <pre><code>sources = Models::Source.where(id: [1, 2, 3])\nresults = pipeline.process(sources, extractor: :llm)\n</code></pre>"},{"location":"api/pipeline/extraction/#process_parallel","title":"process_parallel","text":"<pre><code>def process_parallel(sources, extractor: config.default_extractor)\n</code></pre> <p>Process source items concurrently.</p> <p>Parameters:</p> <ul> <li><code>sources</code> (Array) - Source records</li> <li><code>extractor</code> (Symbol) - Extraction method</li> </ul> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example:</p> <pre><code>results = pipeline.process_parallel(sources, extractor: :llm)\n\nresults.each do |result|\n  puts \"Source #{result[:source_id]}:\"\n  puts \"  Facts: #{result[:facts].count}\"\n  puts \"  Error: #{result[:error]}\" if result[:error]\nend\n</code></pre>"},{"location":"api/pipeline/extraction/#pipeline-steps","title":"Pipeline Steps","text":""},{"location":"api/pipeline/extraction/#sequential-pipeline","title":"Sequential Pipeline","text":"<pre><code>graph LR\n    A[Source] --&gt; B[Validate]\n    B --&gt; C[Extract]\n    C --&gt; D[Validate Facts]\n    D --&gt; E[Results]\n\n    style A fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style B fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style C fill:#047857,stroke:#065F46,color:#FFFFFF\n    style D fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style E fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre> <ol> <li>Validate - Check source is not empty</li> <li>Extract - Run extractor</li> <li>Validate Facts - Filter valid facts</li> <li>Results - Return extracted facts</li> </ol>"},{"location":"api/pipeline/extraction/#parallel-pipeline","title":"Parallel Pipeline","text":"<pre><code>graph TB\n    subgraph Parallel\n        A1[Source 1] --&gt; E1[Extract 1]\n        A2[Source 2] --&gt; E2[Extract 2]\n        A3[Source 3] --&gt; E3[Extract 3]\n    end\n    E1 --&gt; Aggregate\n    E2 --&gt; Aggregate\n    E3 --&gt; Aggregate\n\n    style A1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style A2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style A3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style E1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E2 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E3 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style Aggregate fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre>"},{"location":"api/pipeline/extraction/#result-structure","title":"Result Structure","text":"<pre><code>{\n  source_id: 123,\n  facts: [&lt;Fact&gt;, &lt;Fact&gt;, ...],  # Extracted facts\n  error: nil                      # Error message if failed\n}\n</code></pre>"},{"location":"api/pipeline/extraction/#usage-via-factdb","title":"Usage via FactDb","text":"<pre><code>facts = FactDb.new\n\n# Sequential\nresults = facts.batch_extract(source_ids, parallel: false)\n\n# Parallel (default)\nresults = facts.batch_extract(source_ids, parallel: true)\n</code></pre>"},{"location":"api/pipeline/extraction/#error-handling","title":"Error Handling","text":"<p>The pipeline catches errors per-item:</p> <pre><code>results = pipeline.process_parallel(sources)\n\nresults.each do |result|\n  if result[:error]\n    logger.error \"Source #{result[:source_id]}: #{result[:error]}\"\n  else\n    logger.info \"Source #{result[:source_id]}: #{result[:facts].count} facts\"\n  end\nend\n</code></pre>"},{"location":"api/pipeline/extraction/#performance","title":"Performance","text":""},{"location":"api/pipeline/extraction/#batch-size","title":"Batch Size","text":"<p>Optimal batch size depends on:</p> <ul> <li>Extractor type (LLM has rate limits)</li> <li>Source length</li> <li>System resources</li> </ul> <pre><code># Process in optimal batches\nsources.each_slice(25) do |batch|\n  results = pipeline.process_parallel(batch)\n  process_results(results)\nend\n</code></pre>"},{"location":"api/pipeline/extraction/#memory","title":"Memory","text":"<p>For large batches, process and discard:</p> <pre><code>sources.each_slice(50) do |batch|\n  results = pipeline.process_parallel(batch)\n  save_facts(results.flat_map { |r| r[:facts] })\n  # Results discarded after each batch\nend\n</code></pre>"},{"location":"api/pipeline/resolution/","title":"ResolutionPipeline","text":"<p>Parallel entity resolution and conflict detection.</p>"},{"location":"api/pipeline/resolution/#class-factdbpipelineresolutionpipeline","title":"Class: <code>FactDb::Pipeline::ResolutionPipeline</code>","text":"<pre><code>pipeline = FactDb::Pipeline::ResolutionPipeline.new(config)\n</code></pre>"},{"location":"api/pipeline/resolution/#methods","title":"Methods","text":""},{"location":"api/pipeline/resolution/#resolve_entities","title":"resolve_entities","text":"<pre><code>def resolve_entities(names, type: nil)\n</code></pre> <p>Resolve multiple entity names in parallel.</p> <p>Parameters:</p> <ul> <li><code>names</code> (Array) - Names to resolve <li><code>type</code> (Symbol) - Optional entity type filter</li> <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example:</p> <pre><code>names = [\"Paula Chen\", \"Microsoft\", \"Seattle\"]\nresults = pipeline.resolve_entities(names)\n\nresults.each do |result|\n  puts \"#{result[:name]}: #{result[:status]}\"\n  puts \"  Entity: #{result[:entity]&amp;.name}\"\nend\n</code></pre>"},{"location":"api/pipeline/resolution/#detect_conflicts","title":"detect_conflicts","text":"<pre><code>def detect_conflicts(entity_ids)\n</code></pre> <p>Find fact conflicts for multiple entities in parallel.</p> <p>Parameters:</p> <ul> <li><code>entity_ids</code> (Array) - Entity IDs to check <p>Returns: <code>Array&lt;Hash&gt;</code></p> <p>Example:</p> <pre><code>results = pipeline.detect_conflicts([paula.id, john.id])\n\nresults.each do |result|\n  puts \"Entity #{result[:entity_id]}: #{result[:conflict_count]} conflicts\"\n  result[:conflicts].each do |c|\n    puts \"  - #{c[:fact1].text} vs #{c[:fact2].text}\"\n  end\nend\n</code></pre>"},{"location":"api/pipeline/resolution/#result-structures","title":"Result Structures","text":""},{"location":"api/pipeline/resolution/#resolution-result","title":"Resolution Result","text":"<pre><code>{\n  name: \"Paula Chen\",\n  entity: &lt;Entity&gt;,           # Resolved entity or nil\n  status: :resolved,          # :resolved, :not_found, :error\n  error: nil                  # Error message if failed\n}\n</code></pre>"},{"location":"api/pipeline/resolution/#conflict-detection-result","title":"Conflict Detection Result","text":"<pre><code>{\n  entity_id: 123,\n  conflicts: [\n    {\n      fact1: &lt;Fact&gt;,\n      fact2: &lt;Fact&gt;,\n      similarity: 0.75\n    }\n  ],\n  conflict_count: 1\n}\n</code></pre>"},{"location":"api/pipeline/resolution/#pipeline-steps","title":"Pipeline Steps","text":""},{"location":"api/pipeline/resolution/#entity-resolution-pipeline","title":"Entity Resolution Pipeline","text":"<pre><code>graph TB\n    subgraph Parallel\n        N1[Name 1] --&gt; R1[Resolve 1]\n        N2[Name 2] --&gt; R2[Resolve 2]\n        N3[Name 3] --&gt; R3[Resolve 3]\n    end\n    R1 --&gt; Aggregate\n    R2 --&gt; Aggregate\n    R3 --&gt; Aggregate\n\n    style N1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style N2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style N3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style R1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style R2 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style R3 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style Aggregate fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre>"},{"location":"api/pipeline/resolution/#conflict-detection-pipeline","title":"Conflict Detection Pipeline","text":"<pre><code>graph TB\n    subgraph Parallel\n        E1[Entity 1] --&gt; C1[Find Conflicts 1]\n        E2[Entity 2] --&gt; C2[Find Conflicts 2]\n    end\n    C1 --&gt; Aggregate\n    C2 --&gt; Aggregate\n\n    style E1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E2 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style C1 fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style C2 fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style Aggregate fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre>"},{"location":"api/pipeline/resolution/#usage-via-facts","title":"Usage via Facts","text":"<pre><code>facts = FactDb.new\n\n# Resolve entities\nresults = facts.batch_resolve_entities([\"Paula\", \"Microsoft\"])\n\n# Detect conflicts\nresults = facts.detect_fact_conflicts([entity1.id, entity2.id])\n</code></pre>"},{"location":"api/pipeline/resolution/#resolution-strategies","title":"Resolution Strategies","text":"<p>The pipeline uses the EntityResolver which tries:</p> <ol> <li>Exact match on name</li> <li>Alias match on registered aliases</li> <li>Fuzzy match using Levenshtein distance</li> </ol> <pre><code>FactDb.configure do |config|\n  config.fuzzy_match_threshold = 0.85\nend\n</code></pre>"},{"location":"api/pipeline/resolution/#error-handling","title":"Error Handling","text":"<pre><code>results = pipeline.resolve_entities(names)\n\n# Handle unresolved names\nunresolved = results.select { |r| r[:status] == :not_found }\nunresolved.each do |result|\n  # Optionally create new entities\n  entity = facts.entity_service.create(\n    result[:name],\n    type: :person,\n    metadata: { needs_review: true }\n  )\nend\n\n# Handle errors\nerrors = results.select { |r| r[:status] == :error }\nerrors.each do |result|\n  logger.error \"Resolution failed for #{result[:name]}: #{result[:error]}\"\nend\n</code></pre>"},{"location":"api/pipeline/resolution/#performance-tips","title":"Performance Tips","text":""},{"location":"api/pipeline/resolution/#batch-size","title":"Batch Size","text":"<pre><code># Process in batches for large name lists\nnames.each_slice(100) do |batch|\n  results = pipeline.resolve_entities(batch)\n  process_results(results)\nend\n</code></pre>"},{"location":"api/pipeline/resolution/#pre-warm-cache","title":"Pre-warm Cache","text":"<pre><code># Load entities into memory first\nEntity.where(type: 'person').to_a\n\n# Then resolve\nresults = pipeline.resolve_entities(person_names, type: :person)\n</code></pre>"},{"location":"api/services/","title":"Services","text":"<p>Services provide the business logic layer for FactDb operations.</p>"},{"location":"api/services/#available-services","title":"Available Services","text":"<ul> <li>SourceService - Ingest and manage source content</li> <li>EntityService - Create and resolve entities</li> <li>FactService - Extract and query facts</li> </ul>"},{"location":"api/services/#service-pattern","title":"Service Pattern","text":"<p>All services follow a common pattern:</p> <pre><code>class SomeService\n  attr_reader :config\n\n  def initialize(config = FactDb.config)\n    @config = config\n  end\n\n  # Business methods...\nend\n</code></pre>"},{"location":"api/services/#accessing-services","title":"Accessing Services","text":""},{"location":"api/services/#via-factdb","title":"Via FactDb","text":"<pre><code>facts = FactDb.new\n\nfacts.source_service.create(text, type: :document)\nfacts.entity_service.create(\"Paula\", type: :person)\nfacts.fact_service.create(\"Fact text\", valid_at: Date.today)\n</code></pre>"},{"location":"api/services/#directly","title":"Directly","text":"<pre><code>service = FactDb::Services::SourceService.new(config)\nsource = service.create(text, type: :document)\n</code></pre>"},{"location":"api/services/#common-methods","title":"Common Methods","text":"<p>All services provide these common methods:</p> Method Description <code>find(id)</code> Find record by ID <code>create(...)</code> Create new record <code>update(id, ...)</code> Update existing record <code>search(query)</code> Search records"},{"location":"api/services/entity-service/","title":"EntityService","text":"<p>Service for creating and resolving entities.</p>"},{"location":"api/services/entity-service/#class-factdbservicesentityservice","title":"Class: <code>FactDb::Services::EntityService</code>","text":"<pre><code>service = FactDb::Services::EntityService.new(config)\n</code></pre>"},{"location":"api/services/entity-service/#methods","title":"Methods","text":""},{"location":"api/services/entity-service/#create","title":"create","text":"<pre><code>def create(name, type:, aliases: [], metadata: {})\n</code></pre> <p>Create a new entity.</p> <p>Parameters:</p> <ul> <li><code>name</code> (String) - Authoritative name</li> <li><code>type</code> (Symbol) - Entity type</li> <li><code>aliases</code> (Array) - Alternative names</li> <li><code>metadata</code> (Hash) - Additional attributes</li> </ul> <p>Returns: <code>Models::Entity</code></p> <p>Example:</p> <pre><code>entity = service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\", \"P. Chen\"],\n  metadata: { department: \"Engineering\" }\n)\n</code></pre>"},{"location":"api/services/entity-service/#find","title":"find","text":"<pre><code>def find(id)\n</code></pre> <p>Find entity by ID.</p> <p>Returns: <code>Models::Entity</code></p>"},{"location":"api/services/entity-service/#resolve","title":"resolve","text":"<pre><code>def resolve(name, type: nil)\n</code></pre> <p>Resolve a name to an entity using multiple strategies.</p> <p>Parameters:</p> <ul> <li><code>name</code> (String) - Name to resolve</li> <li><code>type</code> (Symbol) - Optional type filter</li> </ul> <p>Returns: <code>Models::Entity</code> or <code>nil</code></p> <p>Example:</p> <pre><code>entity = service.resolve(\"Paula Chen\", type: :person)\n</code></pre>"},{"location":"api/services/entity-service/#add_alias","title":"add_alias","text":"<pre><code>def add_alias(entity_id, alias_name, type: nil, confidence: 1.0)\n</code></pre> <p>Add an alias to an entity.</p> <p>Example:</p> <pre><code>service.add_alias(entity.id, \"P. Chen\", type: :abbreviation)\n</code></pre>"},{"location":"api/services/entity-service/#remove_alias","title":"remove_alias","text":"<pre><code>def remove_alias(entity_id, alias_name)\n</code></pre> <p>Remove an alias from an entity.</p>"},{"location":"api/services/entity-service/#merge","title":"merge","text":"<pre><code>def merge(keep_id, merge_id)\n</code></pre> <p>Merge two entities (merge_id into keep_id).</p> <p>Example:</p> <pre><code>service.merge(canonical_entity.id, duplicate_entity.id)\n</code></pre>"},{"location":"api/services/entity-service/#update","title":"update","text":"<pre><code>def update(id, **attributes)\n</code></pre> <p>Update entity attributes.</p> <p>Example:</p> <pre><code>service.update(\n  entity.id,\n  name: \"Paula M. Chen\",\n  metadata: { title: \"Senior Engineer\" }\n)\n</code></pre>"},{"location":"api/services/entity-service/#search","title":"search","text":"<pre><code>def search(query, type: nil, limit: 20)\n</code></pre> <p>Search entities by name.</p> <p>Parameters:</p> <ul> <li><code>query</code> (String) - Search query</li> <li><code>type</code> (Symbol) - Optional type filter</li> <li><code>limit</code> (Integer) - Max results</li> </ul> <p>Returns: <code>Array&lt;Models::Entity&gt;</code></p>"},{"location":"api/services/entity-service/#by_type","title":"by_type","text":"<pre><code>def by_type(type)\n</code></pre> <p>Filter entities by type.</p> <p>Returns: <code>ActiveRecord::Relation</code></p>"},{"location":"api/services/entity-service/#in_source","title":"in_source","text":"<pre><code>def in_source(source_id)\n</code></pre> <p>Find entities mentioned in a source.</p> <p>Returns: <code>Array&lt;Models::Entity&gt;</code></p>"},{"location":"api/services/entity-service/#related_to","title":"related_to","text":"<pre><code>def related_to(entity_id)\n</code></pre> <p>Find entities that appear in facts with the given entity.</p> <p>Returns: <code>Array&lt;Models::Entity&gt;</code></p>"},{"location":"api/services/entity-service/#semantic_search","title":"semantic_search","text":"<pre><code>def semantic_search(query, type: nil, limit: 10)\n</code></pre> <p>Semantic similarity search using embeddings.</p> <p>Returns: <code>Array&lt;Models::Entity&gt;</code></p>"},{"location":"api/services/fact-service/","title":"FactService","text":"<p>Service for extracting and querying facts.</p>"},{"location":"api/services/fact-service/#class-factdbservicesfactservice","title":"Class: <code>FactDb::Services::FactService</code>","text":"<pre><code>service = FactDb::Services::FactService.new(config)\n</code></pre>"},{"location":"api/services/fact-service/#attributes","title":"Attributes","text":"Attribute Type Description <code>resolver</code> FactResolver For fact resolution operations"},{"location":"api/services/fact-service/#methods","title":"Methods","text":""},{"location":"api/services/fact-service/#create","title":"create","text":"<pre><code>def create(text, valid_at:, invalid_at: nil, mentions: [], sources: [], confidence: 1.0, metadata: {})\n</code></pre> <p>Create a new fact.</p> <p>Parameters:</p> <ul> <li><code>text</code> (String) - The assertion</li> <li><code>valid_at</code> (Date/Time) - When fact became true</li> <li><code>invalid_at</code> (Date/Time) - When fact stopped (optional)</li> <li><code>mentions</code> (Array) - Entity mentions</li> <li><code>sources</code> (Array) - Source content links</li> <li><code>confidence</code> (Float) - Extraction confidence</li> <li><code>metadata</code> (Hash) - Additional data</li> </ul> <p>Returns: <code>Models::Fact</code></p> <p>Example:</p> <pre><code>fact = service.create(\n  \"Paula Chen is Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" }\n  ],\n  sources: [\n    { source: email, type: \"primary\" }\n  ]\n)\n</code></pre>"},{"location":"api/services/fact-service/#find","title":"find","text":"<pre><code>def find(id)\n</code></pre> <p>Find fact by ID.</p> <p>Returns: <code>Models::Fact</code></p>"},{"location":"api/services/fact-service/#extract_from_source","title":"extract_from_source","text":"<pre><code>def extract_from_source(source_id, extractor: config.default_extractor)\n</code></pre> <p>Extract facts from source using specified extractor.</p> <p>Parameters:</p> <ul> <li><code>source_id</code> (Integer) - Source ID</li> <li><code>extractor</code> (Symbol) - Extractor type (:manual, :llm, :rule_based)</li> </ul> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>facts = service.extract_from_source(source.id, extractor: :llm)\n</code></pre>"},{"location":"api/services/fact-service/#query","title":"query","text":"<pre><code>def query(topic: nil, at: nil, entity: nil, status: :canonical, from: nil, to: nil, limit: nil)\n</code></pre> <p>Query facts with filters.</p> <p>Parameters:</p> <ul> <li><code>topic</code> (String) - Text search</li> <li><code>at</code> (Date/Time) - Point in time</li> <li><code>entity</code> (Integer) - Entity ID</li> <li><code>status</code> (Symbol/Array) - Status filter</li> <li><code>from</code> (Date/Time) - Range start</li> <li><code>to</code> (Date/Time) - Range end</li> <li><code>limit</code> (Integer) - Max results</li> </ul> <p>Returns: <code>ActiveRecord::Relation</code></p> <p>Example:</p> <pre><code># Current facts about Paula\nfacts = service.query(entity: paula.id, status: :canonical)\n\n# Historical facts\nfacts = service.query(entity: paula.id, at: Date.parse(\"2023-06-15\"))\n\n# Facts in a range\nfacts = service.query(\n  entity: paula.id,\n  from: Date.parse(\"2023-01-01\"),\n  to: Date.parse(\"2023-12-31\")\n)\n</code></pre>"},{"location":"api/services/fact-service/#timeline","title":"timeline","text":"<pre><code>def timeline(entity_id:, from: nil, to: nil)\n</code></pre> <p>Build a timeline for an entity.</p> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p> <p>Example:</p> <pre><code>timeline = service.timeline(entity_id: paula.id)\ntimeline.each do |fact|\n  puts \"#{fact.valid_at}: #{fact.text}\"\nend\n</code></pre>"},{"location":"api/services/fact-service/#from_source","title":"from_source","text":"<pre><code>def from_source(source_id)\n</code></pre> <p>Get facts sourced from specific source.</p> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p>"},{"location":"api/services/fact-service/#semantic_search","title":"semantic_search","text":"<pre><code>def semantic_search(query, entity: nil, limit: 10)\n</code></pre> <p>Semantic similarity search.</p> <p>Returns: <code>Array&lt;Models::Fact&gt;</code></p>"},{"location":"api/services/fact-service/#resolver-methods","title":"Resolver Methods","text":"<p>Access via <code>service.resolver</code>:</p>"},{"location":"api/services/fact-service/#supersede","title":"supersede","text":"<pre><code>service.resolver.supersede(old_fact_id, new_text, valid_at: date)\n</code></pre> <p>Supersede an existing fact.</p>"},{"location":"api/services/fact-service/#synthesize","title":"synthesize","text":"<pre><code>service.resolver.synthesize(source_ids, synthesized_text, valid_at: date)\n</code></pre> <p>Create synthesized fact from multiple sources.</p>"},{"location":"api/services/fact-service/#corroborate","title":"corroborate","text":"<pre><code>service.resolver.corroborate(fact_id, corroborating_fact_id)\n</code></pre> <p>Mark fact as corroborated.</p>"},{"location":"api/services/fact-service/#invalidate","title":"invalidate","text":"<pre><code>service.resolver.invalidate(fact_id, at: Time.current)\n</code></pre> <p>Invalidate a fact.</p>"},{"location":"api/services/fact-service/#find_conflicts","title":"find_conflicts","text":"<pre><code>service.resolver.find_conflicts(entity_id: id, topic: text)\n</code></pre> <p>Find potentially conflicting facts.</p>"},{"location":"api/services/fact-service/#resolve_conflict","title":"resolve_conflict","text":"<pre><code>service.resolver.resolve_conflict(keep_id, supersede_ids, reason: text)\n</code></pre> <p>Resolve conflicts by keeping one fact.</p>"},{"location":"api/services/source-service/","title":"SourceService","text":"<p>Service for ingesting and managing source content.</p>"},{"location":"api/services/source-service/#class-factdbservicessourceservice","title":"Class: <code>FactDb::Services::SourceService</code>","text":"<pre><code>service = FactDb::Services::SourceService.new(config)\n</code></pre>"},{"location":"api/services/source-service/#methods","title":"Methods","text":""},{"location":"api/services/source-service/#create","title":"create","text":"<pre><code>def create(content, type:, captured_at: Time.current, metadata: {}, title: nil, source_uri: nil)\n</code></pre> <p>Create new source with automatic deduplication.</p> <p>Parameters:</p> <ul> <li><code>content</code> (String) - Source text content</li> <li><code>type</code> (Symbol) - Content type</li> <li><code>captured_at</code> (Time) - Capture timestamp</li> <li><code>metadata</code> (Hash) - Additional metadata</li> <li><code>title</code> (String) - Optional title</li> <li><code>source_uri</code> (String) - Original location</li> </ul> <p>Returns: <code>Models::Source</code></p> <p>Example:</p> <pre><code>source = service.create(\n  \"Email body text...\",\n  type: :email,\n  title: \"RE: Important\",\n  metadata: { from: \"sender@example.com\" }\n)\n</code></pre>"},{"location":"api/services/source-service/#find","title":"find","text":"<pre><code>def find(id)\n</code></pre> <p>Find source by ID.</p> <p>Returns: <code>Models::Source</code></p>"},{"location":"api/services/source-service/#find_by_hash","title":"find_by_hash","text":"<pre><code>def find_by_hash(hash)\n</code></pre> <p>Find source by SHA256 hash.</p> <p>Returns: <code>Models::Source</code> or <code>nil</code></p> <p>Example:</p> <pre><code>hash = Digest::SHA256.hexdigest(text)\nsource = service.find_by_hash(hash)\n</code></pre>"},{"location":"api/services/source-service/#search","title":"search","text":"<pre><code>def search(query, limit: 20)\n</code></pre> <p>Full-text search sources.</p> <p>Parameters:</p> <ul> <li><code>query</code> (String) - Search query</li> <li><code>limit</code> (Integer) - Max results</li> </ul> <p>Returns: <code>Array&lt;Models::Source&gt;</code></p> <p>Example:</p> <pre><code>results = service.search(\"quarterly report\", limit: 10)\n</code></pre>"},{"location":"api/services/source-service/#semantic_search","title":"semantic_search","text":"<pre><code>def semantic_search(query, limit: 10)\n</code></pre> <p>Semantic similarity search using embeddings.</p> <p>Parameters:</p> <ul> <li><code>query</code> (String) - Search query</li> <li><code>limit</code> (Integer) - Max results</li> </ul> <p>Returns: <code>Array&lt;Models::Source&gt;</code></p> <p>Example:</p> <pre><code>results = service.semantic_search(\"financial performance\")\n</code></pre>"},{"location":"api/services/source-service/#by_type","title":"by_type","text":"<pre><code>def by_type(type)\n</code></pre> <p>Filter sources by type.</p> <p>Returns: <code>ActiveRecord::Relation</code></p> <p>Example:</p> <pre><code>emails = service.by_type(:email)\n</code></pre>"},{"location":"api/services/source-service/#recent","title":"recent","text":"<pre><code>def recent(limit: 20)\n</code></pre> <p>Get recently captured sources.</p> <p>Returns: <code>Array&lt;Models::Source&gt;</code></p>"},{"location":"api/services/source-service/#mentioning_entity","title":"mentioning_entity","text":"<pre><code>def mentioning_entity(entity_id)\n</code></pre> <p>Find sources that mention an entity (via facts).</p> <p>Returns: <code>Array&lt;Models::Source&gt;</code></p> <p>Example:</p> <pre><code>paula_sources = service.mentioning_entity(paula.id)\n</code></pre>"},{"location":"architecture/","title":"Architecture","text":"<p>FactDb is designed around the Event Clock concept - a system for capturing organizational reasoning through temporal facts with full audit trails.</p>"},{"location":"architecture/#design-principles","title":"Design Principles","text":""},{"location":"architecture/#immutable-content","title":"Immutable Content","text":"<p>Source content is never modified after ingestion. This ensures:</p> <ul> <li>Complete audit trails</li> <li>Reproducible fact extraction</li> <li>Historical accuracy</li> </ul>"},{"location":"architecture/#temporal-first","title":"Temporal First","text":"<p>Every fact has temporal bounds (<code>valid_at</code>, <code>invalid_at</code>). This enables:</p> <ul> <li>Point-in-time queries</li> <li>Change tracking</li> <li>Historical analysis</li> </ul>"},{"location":"architecture/#entity-resolution","title":"Entity Resolution","text":"<p>Names and mentions are resolved to canonical entities:</p> <ul> <li>Reduces ambiguity</li> <li>Enables cross-reference</li> <li>Supports alias matching</li> </ul>"},{"location":"architecture/#provenance","title":"Provenance","text":"<p>Every fact links back to source content:</p> <ul> <li>Verifiable assertions</li> <li>Confidence tracking</li> <li>Contradiction detection</li> </ul>"},{"location":"architecture/#system-architecture","title":"System Architecture","text":"<pre><code>graph TB\n    subgraph Input\n        Email[Email]\n        Doc[Documents]\n        News[News]\n        API[APIs]\n    end\n\n    subgraph FactDb[\"FactDb Core\"]\n        SS[SourceService]\n        ES[EntityService]\n        FS[FactService]\n\n        subgraph Extractors\n            ME[ManualExtractor]\n            LE[LLMExtractor]\n            RE[RuleBasedExtractor]\n        end\n\n        subgraph Resolution\n            ER[EntityResolver]\n            FR[FactResolver]\n        end\n\n        subgraph Pipeline\n            EP[ExtractionPipeline]\n            RP[ResolutionPipeline]\n        end\n    end\n\n    subgraph Storage[\"PostgreSQL + pgvector\"]\n        Sources[(Sources)]\n        Entities[(Entities)]\n        Facts[(Facts)]\n    end\n\n    Email --&gt; SS\n    Doc --&gt; SS\n    News --&gt; SS\n    API --&gt; SS\n\n    SS --&gt; Sources\n    ES --&gt; Entities\n    FS --&gt; Facts\n\n    Extractors --&gt; FS\n    Resolution --&gt; ES\n    Resolution --&gt; FS\n    Pipeline --&gt; Extractors\n\n    style Email fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style Doc fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style News fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style API fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style SS fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style ES fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style FS fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style ME fill:#047857,stroke:#065F46,color:#FFFFFF\n    style LE fill:#047857,stroke:#065F46,color:#FFFFFF\n    style RE fill:#047857,stroke:#065F46,color:#FFFFFF\n    style ER fill:#C2410C,stroke:#9A3412,color:#FFFFFF\n    style FR fill:#C2410C,stroke:#9A3412,color:#FFFFFF\n    style EP fill:#7C3AED,stroke:#6D28D9,color:#FFFFFF\n    style RP fill:#7C3AED,stroke:#6D28D9,color:#FFFFFF\n    style Sources fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style Entities fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style Facts fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre>"},{"location":"architecture/#components","title":"Components","text":""},{"location":"architecture/#services","title":"Services","text":"<ul> <li>SourceService - Ingests and manages source content</li> <li>EntityService - Creates and resolves entities</li> <li>FactService - Extracts, creates, and queries facts</li> </ul>"},{"location":"architecture/#extractors","title":"Extractors","text":"<ul> <li>ManualExtractor - API-driven fact creation</li> <li>LLMExtractor - AI-powered extraction using OpenAI, Anthropic, etc.</li> <li>RuleBasedExtractor - Pattern matching with regular expressions</li> </ul>"},{"location":"architecture/#resolution","title":"Resolution","text":"<ul> <li>EntityResolver - Matches mentions to canonical entities</li> <li>FactResolver - Handles supersession, synthesis, and conflicts</li> </ul>"},{"location":"architecture/#pipeline","title":"Pipeline","text":"<ul> <li>ExtractionPipeline - Concurrent fact extraction using SimpleFlow</li> <li>ResolutionPipeline - Parallel entity resolution</li> </ul>"},{"location":"architecture/#data-flow","title":"Data Flow","text":"<ol> <li>Ingest - Raw content enters the system</li> <li>Store - Content is hashed, deduplicated, and stored</li> <li>Extract - Facts are extracted via chosen method</li> <li>Resolve - Entity mentions are resolved to canonical entities</li> <li>Link - Facts are linked to sources and entities</li> <li>Query - Temporal queries retrieve relevant facts</li> </ol>"},{"location":"architecture/#documentation","title":"Documentation","text":"<ul> <li>Three-Layer Model - Content, Entities, Facts</li> <li>Temporal Facts - Validity periods and status</li> <li>Entity Resolution - Resolving mentions</li> <li>Database Schema - Table structure</li> </ul>"},{"location":"architecture/database-schema/","title":"Database Schema","text":"<p>FactDb uses PostgreSQL with the pgvector extension for semantic search capabilities.</p>"},{"location":"architecture/database-schema/#entity-relationship-diagram","title":"Entity Relationship Diagram","text":"<pre><code>erDiagram\n    sources ||--o{ fact_sources : \"sourced by\"\n    entities ||--o{ entity_aliases : \"has\"\n    entities ||--o{ entity_mentions : \"mentioned in\"\n    facts ||--o{ entity_mentions : \"mentions\"\n    facts ||--o{ fact_sources : \"sourced from\"\n    facts ||--o| facts : \"superseded by\"\n\n    sources {\n        bigint id PK\n        string content_hash UK\n        string type\n        text content\n        string title\n        string source_uri\n        jsonb metadata\n        vector embedding\n        timestamptz captured_at\n        timestamptz created_at\n    }\n\n    entities {\n        bigint id PK\n        string name\n        string type\n        string resolution_status\n        bigint canonical_id FK\n        jsonb metadata\n        vector embedding\n        timestamptz created_at\n    }\n\n    entity_aliases {\n        bigint id PK\n        bigint entity_id FK\n        string name\n        string type\n        float confidence\n    }\n\n    facts {\n        bigint id PK\n        text text\n        string digest\n        timestamptz valid_at\n        timestamptz invalid_at\n        string status\n        bigint superseded_by_id FK\n        bigint[] derived_from_ids\n        bigint[] corroborated_by_ids\n        float confidence\n        string extraction_method\n        jsonb metadata\n        vector embedding\n        timestamptz created_at\n    }\n\n    entity_mentions {\n        bigint id PK\n        bigint fact_id FK\n        bigint entity_id FK\n        string mention_text\n        string mention_role\n        float confidence\n    }\n\n    fact_sources {\n        bigint id PK\n        bigint fact_id FK\n        bigint source_id FK\n        string source_type\n        text excerpt\n        float confidence\n    }</code></pre>"},{"location":"architecture/database-schema/#tables","title":"Tables","text":""},{"location":"architecture/database-schema/#sources","title":"sources","text":"<p>Stores immutable source content.</p> <pre><code>CREATE TABLE sources (\n    id BIGSERIAL PRIMARY KEY,\n    content_hash VARCHAR(64) NOT NULL UNIQUE,\n    type VARCHAR(50) NOT NULL,\n    content TEXT NOT NULL,\n    title VARCHAR(255),\n    source_uri TEXT,\n    metadata JSONB NOT NULL DEFAULT '{}',\n    embedding VECTOR(1536),\n    captured_at TIMESTAMPTZ NOT NULL,\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_sources_type ON sources(type);\nCREATE INDEX idx_sources_captured ON sources(captured_at);\nCREATE INDEX idx_sources_text ON sources USING gin(to_tsvector('english', content));\nCREATE INDEX idx_sources_embedding ON sources USING hnsw(embedding vector_cosine_ops);\n</code></pre>"},{"location":"architecture/database-schema/#entities","title":"entities","text":"<p>Stores resolved identities.</p> <pre><code>CREATE TABLE entities (\n    id BIGSERIAL PRIMARY KEY,\n    name VARCHAR(255) NOT NULL,\n    type VARCHAR(50) NOT NULL,\n    resolution_status VARCHAR(20) NOT NULL DEFAULT 'unresolved',\n    canonical_id BIGINT REFERENCES entities(id),\n    metadata JSONB NOT NULL DEFAULT '{}',\n    embedding VECTOR(1536),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_entities_name ON entities(name);\nCREATE INDEX idx_entities_type ON entities(type);\nCREATE INDEX idx_entities_status ON entities(resolution_status);\nCREATE INDEX idx_entities_embedding ON entities USING hnsw(embedding vector_cosine_ops);\n</code></pre>"},{"location":"architecture/database-schema/#entity_aliases","title":"entity_aliases","text":"<p>Stores alternative names for entities.</p> <pre><code>CREATE TABLE entity_aliases (\n    id BIGSERIAL PRIMARY KEY,\n    entity_id BIGINT NOT NULL REFERENCES entities(id) ON DELETE CASCADE,\n    name VARCHAR(255) NOT NULL,\n    type VARCHAR(50),\n    confidence FLOAT DEFAULT 1.0\n);\n\nCREATE INDEX idx_aliases_entity ON entity_aliases(entity_id);\nCREATE INDEX idx_aliases_text ON entity_aliases(name);\nCREATE UNIQUE INDEX idx_aliases_unique ON entity_aliases(entity_id, name);\n</code></pre>"},{"location":"architecture/database-schema/#facts","title":"facts","text":"<p>Stores temporal assertions.</p> <pre><code>CREATE TABLE facts (\n    id BIGSERIAL PRIMARY KEY,\n    text TEXT NOT NULL,\n    digest VARCHAR(64) NOT NULL,\n    valid_at TIMESTAMPTZ NOT NULL,\n    invalid_at TIMESTAMPTZ,\n    status VARCHAR(20) NOT NULL DEFAULT 'canonical',\n    superseded_by_id BIGINT REFERENCES facts(id),\n    derived_from_ids BIGINT[],\n    corroborated_by_ids BIGINT[],\n    confidence FLOAT DEFAULT 1.0,\n    extraction_method VARCHAR(50) NOT NULL,\n    metadata JSONB NOT NULL DEFAULT '{}',\n    embedding VECTOR(1536),\n    created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()\n);\n\nCREATE INDEX idx_facts_status ON facts(status);\nCREATE INDEX idx_facts_valid ON facts(valid_at);\nCREATE INDEX idx_facts_invalid ON facts(invalid_at);\nCREATE INDEX idx_facts_temporal ON facts(valid_at, invalid_at);\nCREATE INDEX idx_facts_method ON facts(extraction_method);\nCREATE INDEX idx_facts_text ON facts USING gin(to_tsvector('english', text));\nCREATE INDEX idx_facts_embedding ON facts USING hnsw(embedding vector_cosine_ops);\n</code></pre>"},{"location":"architecture/database-schema/#entity_mentions","title":"entity_mentions","text":"<p>Links facts to mentioned entities.</p> <pre><code>CREATE TABLE entity_mentions (\n    id BIGSERIAL PRIMARY KEY,\n    fact_id BIGINT NOT NULL REFERENCES facts(id) ON DELETE CASCADE,\n    entity_id BIGINT NOT NULL REFERENCES entities(id),\n    mention_text VARCHAR(255) NOT NULL,\n    mention_role VARCHAR(50) NOT NULL,\n    confidence FLOAT DEFAULT 1.0\n);\n\nCREATE INDEX idx_mentions_fact ON entity_mentions(fact_id);\nCREATE INDEX idx_mentions_entity ON entity_mentions(entity_id);\nCREATE INDEX idx_mentions_role ON entity_mentions(mention_role);\n</code></pre>"},{"location":"architecture/database-schema/#fact_sources","title":"fact_sources","text":"<p>Links facts to source content.</p> <pre><code>CREATE TABLE fact_sources (\n    id BIGSERIAL PRIMARY KEY,\n    fact_id BIGINT NOT NULL REFERENCES facts(id) ON DELETE CASCADE,\n    source_id BIGINT NOT NULL REFERENCES sources(id),\n    source_type VARCHAR(50) NOT NULL DEFAULT 'primary',\n    excerpt TEXT,\n    confidence FLOAT DEFAULT 1.0\n);\n\nCREATE INDEX idx_fact_sources_fact ON fact_sources(fact_id);\nCREATE INDEX idx_fact_sources_source ON fact_sources(source_id);\nCREATE INDEX idx_fact_sources_type ON fact_sources(source_type);\n</code></pre>"},{"location":"architecture/database-schema/#vector-indexes","title":"Vector Indexes","text":"<p>FactDb uses HNSW indexes for fast approximate nearest neighbor search:</p> <pre><code>-- Sources semantic search\nCREATE INDEX idx_sources_embedding ON sources\n    USING hnsw(embedding vector_cosine_ops)\n    WITH (m = 16, ef_construction = 64);\n\n-- Entities semantic search\nCREATE INDEX idx_entities_embedding ON entities\n    USING hnsw(embedding vector_cosine_ops)\n    WITH (m = 16, ef_construction = 64);\n\n-- Facts semantic search\nCREATE INDEX idx_facts_embedding ON facts\n    USING hnsw(embedding vector_cosine_ops)\n    WITH (m = 16, ef_construction = 64);\n</code></pre>"},{"location":"architecture/database-schema/#temporal-query-patterns","title":"Temporal Query Patterns","text":""},{"location":"architecture/database-schema/#currently-valid-facts","title":"Currently Valid Facts","text":"<pre><code>SELECT * FROM facts\nWHERE status = 'canonical'\nAND invalid_at IS NULL;\n</code></pre>"},{"location":"architecture/database-schema/#facts-valid-at-point-in-time","title":"Facts Valid at Point in Time","text":"<pre><code>SELECT * FROM facts\nWHERE status IN ('canonical', 'corroborated')\nAND valid_at &lt;= '2024-03-15'\nAND (invalid_at IS NULL OR invalid_at &gt; '2024-03-15');\n</code></pre>"},{"location":"architecture/database-schema/#entity-timeline","title":"Entity Timeline","text":"<pre><code>SELECT f.* FROM facts f\nJOIN entity_mentions em ON em.fact_id = f.id\nWHERE em.entity_id = 123\nORDER BY f.valid_at ASC;\n</code></pre>"},{"location":"architecture/database-schema/#semantic-search","title":"Semantic Search","text":"<pre><code>SELECT *, embedding &lt;=&gt; '[...]' AS distance\nFROM sources\nORDER BY embedding &lt;=&gt; '[...]'\nLIMIT 10;\n</code></pre>"},{"location":"architecture/database-schema/#maintenance","title":"Maintenance","text":""},{"location":"architecture/database-schema/#vacuum-and-analyze","title":"Vacuum and Analyze","text":"<pre><code>VACUUM ANALYZE sources;\nVACUUM ANALYZE entities;\nVACUUM ANALYZE facts;\n</code></pre>"},{"location":"architecture/database-schema/#reindex-vectors","title":"Reindex Vectors","text":"<pre><code>REINDEX INDEX idx_sources_embedding;\nREINDEX INDEX idx_entities_embedding;\nREINDEX INDEX idx_facts_embedding;\n</code></pre>"},{"location":"architecture/entity-resolution/","title":"Entity Resolution","text":"<p>Entity resolution is the process of matching text mentions to canonical entities in the system.</p>"},{"location":"architecture/entity-resolution/#overview","title":"Overview","text":"<p>When extracting facts from content, mentions like \"Paula\", \"P. Chen\", or \"Paula Chen\" need to be resolved to a single canonical entity.</p> <pre><code>graph LR\n    M1[\"'Paula'\"] --&gt; R{EntityResolver}\n    M2[\"'P. Chen'\"] --&gt; R\n    M3[\"'Paula Chen'\"] --&gt; R\n    M4[\"'Chen, Paula'\"] --&gt; R\n    R --&gt; E[\"Entity: Paula Chen\"]\n\n    style M1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style M2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style M3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style M4 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style R fill:#B45309,stroke:#92400E,color:#FFFFFF\n    style E fill:#047857,stroke:#065F46,color:#FFFFFF</code></pre>"},{"location":"architecture/entity-resolution/#resolution-strategies","title":"Resolution Strategies","text":"<p>The resolver tries multiple strategies in order:</p>"},{"location":"architecture/entity-resolution/#1-exact-match","title":"1. Exact Match","text":"<p>Direct match against canonical names:</p> <pre><code># Looking for \"Microsoft\"\nentity = facts.resolve_entity(\"Microsoft\")\n# Matches: Entity(name: \"Microsoft\")\n</code></pre>"},{"location":"architecture/entity-resolution/#2-alias-match","title":"2. Alias Match","text":"<p>Match against registered aliases:</p> <pre><code># Entity has aliases: [\"MS\", \"MSFT\", \"Microsoft Corp\"]\nentity = facts.resolve_entity(\"MSFT\")\n# Matches via alias\n</code></pre>"},{"location":"architecture/entity-resolution/#3-fuzzy-match","title":"3. Fuzzy Match","text":"<p>Levenshtein distance for typos and variations:</p> <pre><code># Looking for \"Microsft\" (typo)\nentity = facts.resolve_entity(\"Microsft\")\n# Fuzzy matches \"Microsoft\" if similarity &gt; threshold\n</code></pre> <p>Configuration:</p> <pre><code>FactDb.configure do |config|\n  config.fuzzy_match_threshold = 0.85  # 85% similarity required\n  config.auto_merge_threshold = 0.95   # Auto-merge at 95%\nend\n</code></pre>"},{"location":"architecture/entity-resolution/#4-type-constrained","title":"4. Type-Constrained","text":"<p>Limit matches to specific entity types:</p> <pre><code># Only match person entities\nperson = facts.resolve_entity(\"Paula\", type: :person)\n\n# Only match organizations\norg = facts.resolve_entity(\"Platform\", type: :organization)\n</code></pre>"},{"location":"architecture/entity-resolution/#creating-entities","title":"Creating Entities","text":""},{"location":"architecture/entity-resolution/#basic-creation","title":"Basic Creation","text":"<pre><code>entity = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#with-aliases","title":"With Aliases","text":"<pre><code>entity = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\", \"P. Chen\", \"Chen, Paula\"]\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#with-metadata","title":"With Metadata","text":"<pre><code>entity = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\"],\n  metadata: {\n    department: \"Engineering\",\n    start_date: \"2024-01-10\",\n    employee_id: \"E12345\"\n  }\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#managing-aliases","title":"Managing Aliases","text":""},{"location":"architecture/entity-resolution/#add-alias","title":"Add Alias","text":"<pre><code>facts.entity_service.add_alias(\n  entity.id,\n  \"P. Chen\",\n  type: :abbreviation,\n  confidence: 0.9\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#list-aliases","title":"List Aliases","text":"<pre><code>entity.entity_aliases.each do |alias_record|\n  puts \"#{alias_record.name} (#{alias_record.type})\"\nend\n</code></pre>"},{"location":"architecture/entity-resolution/#remove-alias","title":"Remove Alias","text":"<pre><code>facts.entity_service.remove_alias(entity.id, \"Old Name\")\n</code></pre>"},{"location":"architecture/entity-resolution/#merging-entities","title":"Merging Entities","text":"<p>When duplicate entities are discovered:</p> <pre><code># Merge entity2 into entity1\nfacts.entity_service.merge(\n  entity1.id,  # Keep this one\n  entity2.id   # Merge into entity1\n)\n\n# After merge:\n# - entity2.resolution_status =&gt; \"merged\"\n# - entity2.canonical_id =&gt; entity1.id\n# - All facts mentioning entity2 now also reference entity1\n</code></pre>"},{"location":"architecture/entity-resolution/#automatic-merging","title":"Automatic Merging","text":"<p>High-confidence matches can be auto-merged:</p> <pre><code>FactDb.configure do |config|\n  config.auto_merge_threshold = 0.95\nend\n\n# When resolving, if similarity &gt; 0.95, entities auto-merge\n</code></pre>"},{"location":"architecture/entity-resolution/#resolution-in-extraction","title":"Resolution in Extraction","text":""},{"location":"architecture/entity-resolution/#manual-resolution","title":"Manual Resolution","text":"<pre><code>fact = facts.fact_service.create(\n  \"Paula joined the team\",\n  valid_at: Date.today,\n  mentions: [\n    {\n      entity: paula_entity,\n      text: \"Paula\",\n      role: \"subject\",\n      confidence: 1.0\n    }\n  ]\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#automatic-resolution","title":"Automatic Resolution","text":"<p>The LLM extractor resolves mentions automatically:</p> <pre><code>extracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  fact.entity_mentions.each do |mention|\n    puts \"Resolved '#{mention.mention_text}' to #{mention.entity.name}\"\n    puts \"  Role: #{mention.mention_role}\"\n    puts \"  Confidence: #{mention.confidence}\"\n  end\nend\n</code></pre>"},{"location":"architecture/entity-resolution/#mention-roles","title":"Mention Roles","text":"<p>When linking entities to facts, specify the role:</p> Role Description Example <code>subject</code> Primary actor \"Paula joined...\" <code>object</code> Target of action \"...hired Paula\" <code>organization</code> Company/team \"...at Microsoft\" <code>location</code> Place \"...in Seattle\" <code>role</code> Job title/position \"...as Engineer\" <code>temporal</code> Time reference \"...in Q4 2024\" <pre><code>fact = facts.fact_service.create(\n  \"Paula Chen joined Microsoft as Principal Engineer in Seattle\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: microsoft, role: \"organization\", text: \"Microsoft\" },\n    { entity: seattle, role: \"location\", text: \"Seattle\" }\n  ]\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#batch-resolution","title":"Batch Resolution","text":"<p>For processing multiple entities efficiently:</p> <pre><code>names = [\"Paula Chen\", \"John Smith\", \"Acme Corp\", \"Seattle\"]\n\nresults = facts.batch_resolve_entities(names)\n\nresults.each do |result|\n  puts \"#{result[:name]}: #{result[:status]}\"\n  puts \"  Entity: #{result[:entity]&amp;.name}\"\nend\n</code></pre>"},{"location":"architecture/entity-resolution/#best-practices","title":"Best Practices","text":""},{"location":"architecture/entity-resolution/#1-create-comprehensive-aliases","title":"1. Create Comprehensive Aliases","text":"<pre><code># Include common variations\nentity = facts.entity_service.create(\n  \"International Business Machines Corporation\",\n  type: :organization,\n  aliases: [\n    \"IBM\",\n    \"Big Blue\",\n    \"International Business Machines\"\n  ]\n)\n</code></pre>"},{"location":"architecture/entity-resolution/#2-use-type-constraints","title":"2. Use Type Constraints","text":"<pre><code># Avoid ambiguous matches\nentity = facts.resolve_entity(\"Apple\", type: :organization)\n# Won't match \"Apple\" as a fruit/food entity\n</code></pre>"},{"location":"architecture/entity-resolution/#3-review-fuzzy-matches","title":"3. Review Fuzzy Matches","text":"<pre><code># Log low-confidence resolutions for review\nif resolution.confidence &lt; 0.9\n  logger.warn \"Low confidence resolution: #{resolution}\"\nend\n</code></pre>"},{"location":"architecture/entity-resolution/#4-handle-unresolved-mentions","title":"4. Handle Unresolved Mentions","text":"<pre><code>entity = facts.resolve_entity(\"Unknown Person\")\nif entity.nil?\n  # Create new entity or flag for review\n  entity = facts.entity_service.create(\n    \"Unknown Person\",\n    type: :person,\n    metadata: { needs_review: true }\n  )\nend\n</code></pre>"},{"location":"architecture/temporal-facts/","title":"Temporal Facts","text":"<p>Temporal facts are the core innovation of FactDb - assertions with explicit validity periods that enable point-in-time queries.</p>"},{"location":"architecture/temporal-facts/#validity-periods","title":"Validity Periods","text":"<p>Every fact has two timestamps:</p> <pre><code>{\n  valid_at: \"2024-01-10T00:00:00Z\",   # When fact became true\n  invalid_at: \"2024-06-01T00:00:00Z\"  # When fact stopped being true (or nil)\n}\n</code></pre>"},{"location":"architecture/temporal-facts/#currently-valid","title":"Currently Valid","text":"<p>Facts with <code>invalid_at: nil</code> are currently valid:</p> <pre><code># Paula is currently a Principal Engineer\n{\n  text: \"Paula Chen is Principal Engineer\",\n  valid_at: \"2024-01-10\",\n  invalid_at: nil\n}\n</code></pre>"},{"location":"architecture/temporal-facts/#historical","title":"Historical","text":"<p>Facts with both dates represent historical periods:</p> <pre><code># Paula was Senior Engineer before promotion\n{\n  text: \"Paula Chen is Senior Engineer\",\n  valid_at: \"2022-03-15\",\n  invalid_at: \"2024-01-10\"\n}\n</code></pre>"},{"location":"architecture/temporal-facts/#temporal-queries","title":"Temporal Queries","text":""},{"location":"architecture/temporal-facts/#current-facts","title":"Current Facts","text":"<pre><code># Get facts valid right now\ncurrent = facts.query_facts(\n  entity: paula.id,\n  status: :canonical\n)\n\n# Shorthand\ncurrent = facts.current_facts_for(paula.id)\n</code></pre>"},{"location":"architecture/temporal-facts/#point-in-time","title":"Point-in-Time","text":"<pre><code># What was true on a specific date?\nqueried = facts.facts_at(\n  Date.parse(\"2023-06-15\"),\n  entity: paula.id\n)\n</code></pre>"},{"location":"architecture/temporal-facts/#time-range","title":"Time Range","text":"<pre><code># Facts active during a period\nqueried = facts.fact_service.query(\n  entity: paula.id,\n  from: Date.parse(\"2023-01-01\"),\n  to: Date.parse(\"2023-12-31\")\n)\n</code></pre>"},{"location":"architecture/temporal-facts/#fact-status","title":"Fact Status","text":"<p>Facts move through different statuses as information evolves:</p> <pre><code>stateDiagram-v2\n    [*] --&gt; canonical: Extracted\n    canonical --&gt; corroborated: 2+ sources confirm\n    canonical --&gt; superseded: New info replaces\n    corroborated --&gt; superseded: Later replaced\n    canonical --&gt; synthesized: Combined\n    superseded --&gt; [*]\n\n    classDef blue fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    classDef green fill:#047857,stroke:#065F46,color:#FFFFFF\n    classDef red fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    classDef yellow fill:#B45309,stroke:#92400E,color:#FFFFFF\n\n    class canonical blue\n    class corroborated green\n    class superseded red\n    class synthesized yellow</code></pre>"},{"location":"architecture/temporal-facts/#canonical","title":"Canonical","text":"<p>The current authoritative version of a fact:</p> <pre><code>fact = facts.fact_service.create(\n  \"Paula Chen is Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [{ entity: paula, role: \"subject\" }]\n)\n# fact.status =&gt; \"canonical\"\n</code></pre>"},{"location":"architecture/temporal-facts/#superseded","title":"Superseded","text":"<p>When information changes, old facts are superseded:</p> <pre><code># Paula gets promoted\nnew_fact = facts.fact_service.resolver.supersede(\n  old_fact.id,\n  \"Paula Chen is Senior Principal Engineer\",\n  valid_at: Date.parse(\"2024-06-01\")\n)\n\n# old_fact.status =&gt; \"superseded\"\n# old_fact.invalid_at =&gt; \"2024-06-01\"\n# old_fact.superseded_by_id =&gt; new_fact.id\n</code></pre>"},{"location":"architecture/temporal-facts/#corroborated","title":"Corroborated","text":"<p>Facts confirmed by multiple independent sources:</p> <pre><code># Two sources say the same thing\nfacts.fact_service.resolver.corroborate(fact.id, other_fact.id)\nfacts.fact_service.resolver.corroborate(fact.id, third_fact.id)\n\n# After 2+ corroborations\nfact.reload\n# fact.status =&gt; \"corroborated\"\n# fact.corroborated_by_ids =&gt; [other_fact.id, third_fact.id]\n</code></pre>"},{"location":"architecture/temporal-facts/#synthesized","title":"Synthesized","text":"<p>Derived facts combine information from multiple sources:</p> <pre><code>synthesized = facts.fact_service.resolver.synthesize(\n  [fact1.id, fact2.id, fact3.id],\n  \"Paula worked at Microsoft from Jan 2024 to present, starting as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\")\n)\n\n# synthesized.status =&gt; \"synthesized\"\n# synthesized.derived_from_ids =&gt; [fact1.id, fact2.id, fact3.id]\n</code></pre>"},{"location":"architecture/temporal-facts/#timelines","title":"Timelines","text":"<p>Build complete timelines for entities:</p> <pre><code>timeline = facts.timeline_for(paula.id)\n\n# Returns chronological list of facts\ntimeline.each do |entry|\n  puts \"#{entry.valid_at}: #{entry.text}\"\n  puts \"  Until: #{entry.invalid_at || 'present'}\"\nend\n</code></pre>"},{"location":"architecture/temporal-facts/#timeline-example","title":"Timeline Example","text":"<pre><code>2022-03-15: Paula Chen joined Company as Software Engineer\n  Until: 2023-01-10\n\n2023-01-10: Paula Chen promoted to Senior Engineer\n  Until: 2024-01-10\n\n2024-01-10: Paula Chen is Principal Engineer at Microsoft\n  Until: present\n</code></pre>"},{"location":"architecture/temporal-facts/#conflict-detection","title":"Conflict Detection","text":"<p>FactDb can detect potentially conflicting facts:</p> <pre><code>conflicts = facts.fact_service.resolver.find_conflicts(\n  entity_id: paula.id,\n  topic: \"title\"\n)\n\nconflicts.each do |conflict|\n  puts \"Potential conflict:\"\n  puts \"  Fact 1: #{conflict[:fact1].text}\"\n  puts \"  Fact 2: #{conflict[:fact2].text}\"\n  puts \"  Similarity: #{conflict[:similarity]}\"\nend\n</code></pre>"},{"location":"architecture/temporal-facts/#resolving-conflicts","title":"Resolving Conflicts","text":"<pre><code># Keep one fact, supersede the others\nfacts.fact_service.resolver.resolve_conflict(\n  keep_fact_id: correct_fact.id,\n  supersede_fact_ids: [wrong_fact.id],\n  reason: \"Verified with HR records\"\n)\n</code></pre>"},{"location":"architecture/temporal-facts/#best-practices","title":"Best Practices","text":""},{"location":"architecture/temporal-facts/#1-always-set-valid_at","title":"1. Always Set valid_at","text":"<pre><code># Good - explicit date\nfacts.fact_service.create(\n  \"Paula joined the team\",\n  valid_at: Date.parse(\"2024-01-10\")\n)\n\n# Avoid - implicit current time\n# valid_at defaults to Time.current if not provided\n</code></pre>"},{"location":"architecture/temporal-facts/#2-supersede-dont-delete","title":"2. Supersede Don't Delete","text":"<pre><code># Good - supersede old fact\nfacts.fact_service.resolver.supersede(\n  old_fact.id,\n  \"Updated information\",\n  valid_at: Date.today\n)\n\n# Avoid - deleting facts\n# old_fact.destroy  # Loses audit trail\n</code></pre>"},{"location":"architecture/temporal-facts/#3-track-confidence","title":"3. Track Confidence","text":"<pre><code>fact = facts.fact_service.create(\n  \"Paula may be promoted soon\",\n  valid_at: Date.today,\n  confidence: 0.6  # Lower confidence for speculation\n)\n</code></pre>"},{"location":"architecture/temporal-facts/#4-link-sources","title":"4. Link Sources","text":"<pre><code>fact = facts.fact_service.create(\n  \"Paula is Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  sources: [\n    { content: email, type: \"primary\", excerpt: \"...accepted the offer...\" },\n    { content: announcement, type: \"supporting\" }\n  ]\n)\n</code></pre>"},{"location":"architecture/three-layer-model/","title":"Three-Layer Model","text":"<p>FactDb organizes information into three distinct layers, each with specific responsibilities.</p>"},{"location":"architecture/three-layer-model/#overview","title":"Overview","text":"<pre><code>graph TB\n    subgraph Layer1[\"Layer 1: Content\"]\n        C1[Immutable Documents]\n        C2[Source Evidence]\n        C3[Captured Timestamps]\n    end\n\n    subgraph Layer2[\"Layer 2: Entities\"]\n        E1[Canonical Names]\n        E2[Aliases]\n        E3[Types]\n    end\n\n    subgraph Layer3[\"Layer 3: Facts\"]\n        F1[Temporal Assertions]\n        F2[Validity Periods]\n        F3[Status Tracking]\n    end\n\n    Layer1 --&gt; Layer3\n    Layer2 --&gt; Layer3\n\n    style C1 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style C2 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style C3 fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style E1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E2 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E3 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style F1 fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style F2 fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style F3 fill:#B91C1C,stroke:#991B1B,color:#FFFFFF</code></pre>"},{"location":"architecture/three-layer-model/#layer-1-content","title":"Layer 1: Content","text":"<p>The content layer stores raw source material that serves as evidence for facts.</p>"},{"location":"architecture/three-layer-model/#characteristics","title":"Characteristics","text":"Property Description Immutable Content never changes after ingestion Deduplicated SHA256 hash prevents duplicate storage Timestamped <code>captured_at</code> records when content was obtained Typed Categories like email, document, article Searchable Full-text and semantic vector search"},{"location":"architecture/three-layer-model/#content-types","title":"Content Types","text":"<pre><code># Common content types\n:email        # Email messages\n:document     # General documents\n:article      # News articles\n:transcript   # Meeting transcripts\n:report       # Reports and analysis\n:announcement # Official announcements\n:social       # Social media posts\n</code></pre>"},{"location":"architecture/three-layer-model/#example","title":"Example","text":"<pre><code>source = facts.ingest(\n  \"Paula Chen accepted the offer for Principal Engineer...\",\n  type: :email,\n  title: \"RE: Offer Letter - Paula Chen\",\n  source_uri: \"mailto:hr@company.com/12345\",\n  captured_at: Time.current,\n  metadata: {\n    from: \"hr@company.com\",\n    to: \"hiring@company.com\",\n    subject: \"RE: Offer Letter - Paula Chen\"\n  }\n)\n</code></pre>"},{"location":"architecture/three-layer-model/#layer-2-entities","title":"Layer 2: Entities","text":"<p>Entities represent real-world things mentioned in content.</p>"},{"location":"architecture/three-layer-model/#entity-types","title":"Entity Types","text":"Type Description Examples <code>person</code> Individual people Paula Chen, John Smith <code>organization</code> Companies, teams, groups Microsoft, Platform Team <code>place</code> Locations San Francisco, Building A <code>product</code> Products and services Windows 11, Azure <code>event</code> Named events Q4 Earnings, Annual Review"},{"location":"architecture/three-layer-model/#resolution-status","title":"Resolution Status","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; unresolved: Created\n    unresolved --&gt; resolved: Confirmed identity\n    resolved --&gt; merged: Duplicate found\n    merged --&gt; [*]: Points to canonical\n\n    classDef blue fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    classDef green fill:#047857,stroke:#065F46,color:#FFFFFF\n    classDef red fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n\n    class unresolved blue\n    class resolved green\n    class merged red</code></pre> <ul> <li>unresolved - Entity created but not confirmed</li> <li>resolved - Entity identity confirmed</li> <li>merged - Entity merged into another (canonical) entity</li> </ul>"},{"location":"architecture/three-layer-model/#aliases","title":"Aliases","text":"<p>Entities can have multiple aliases for flexible matching:</p> <pre><code>entity = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\n    \"Paula\",\n    \"P. Chen\",\n    \"Chen, Paula\"\n  ]\n)\n</code></pre>"},{"location":"architecture/three-layer-model/#layer-3-facts","title":"Layer 3: Facts","text":"<p>Facts are temporal assertions about entities, extracted from content.</p>"},{"location":"architecture/three-layer-model/#fact-structure","title":"Fact Structure","text":"<pre><code>fact = Models::Fact.new(\n  text: \"Paula Chen is Principal Engineer at Microsoft\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  invalid_at: nil,  # Still valid\n  status: \"canonical\",\n  confidence: 0.95,\n  extraction_method: \"llm\"\n)\n</code></pre>"},{"location":"architecture/three-layer-model/#temporal-bounds","title":"Temporal Bounds","text":"<p>Every fact has:</p> <ul> <li><code>valid_at</code> - When the fact became true (required)</li> <li><code>invalid_at</code> - When the fact stopped being true (nil if current)</li> </ul> <pre><code># Currently valid fact\nfact1 = { valid_at: \"2024-01-10\", invalid_at: nil }\n\n# Historical fact\nfact2 = { valid_at: \"2023-01-01\", invalid_at: \"2024-01-09\" }\n\n# Point-in-time query\nfacts.facts_at(Date.parse(\"2023-06-15\"))  # Returns fact2\nfacts.facts_at(Date.parse(\"2024-02-01\"))  # Returns fact1\n</code></pre>"},{"location":"architecture/three-layer-model/#fact-status","title":"Fact Status","text":"Status Description <code>canonical</code> Current authoritative version <code>superseded</code> Replaced by newer information <code>corroborated</code> Confirmed by multiple sources <code>synthesized</code> Derived from multiple facts"},{"location":"architecture/three-layer-model/#relationships","title":"Relationships","text":"<p>Facts connect to both content and entities:</p> <pre><code>graph LR\n    S[Source] --&gt;|fact_sources| F[Fact]\n    F --&gt;|entity_mentions| E1[Entity 1]\n    F --&gt;|entity_mentions| E2[Entity 2]\n\n    style S fill:#1E40AF,stroke:#1E3A8A,color:#FFFFFF\n    style F fill:#B91C1C,stroke:#991B1B,color:#FFFFFF\n    style E1 fill:#047857,stroke:#065F46,color:#FFFFFF\n    style E2 fill:#047857,stroke:#065F46,color:#FFFFFF</code></pre>"},{"location":"architecture/three-layer-model/#layer-interactions","title":"Layer Interactions","text":""},{"location":"architecture/three-layer-model/#source-to-facts","title":"Source to Facts","text":"<p>Facts are extracted from sources and maintain source links:</p> <pre><code># Extract facts from source\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\n# Each fact links back to source\nextracted.first.fact_sources.each do |fs|\n  puts fs.source.title\n  puts fs.excerpt\nend\n</code></pre>"},{"location":"architecture/three-layer-model/#entities-to-facts","title":"Entities to Facts","text":"<p>Facts mention entities with specific roles:</p> <pre><code>fact.entity_mentions.each do |mention|\n  puts \"#{mention.entity.name}: #{mention.mention_role}\"\nend\n# Output:\n# Paula Chen: subject\n# Microsoft: organization\n# Principal Engineer: role\n</code></pre>"},{"location":"architecture/three-layer-model/#cross-layer-queries","title":"Cross-Layer Queries","text":"<p>Query across all layers:</p> <pre><code># Find all sources about an entity\nsources = facts.source_service.mentioning_entity(paula.id)\n\n# Find all entities mentioned in source\nentities = facts.entity_service.in_source(source.id)\n\n# Find all facts from a specific source\nsource_facts = facts.fact_service.from_source(source.id)\n</code></pre>"},{"location":"examples/","title":"Examples","text":"<p>Practical examples demonstrating FactDb usage patterns.</p>"},{"location":"examples/#getting-started","title":"Getting Started","text":"<ul> <li>Basic Usage - Simple introduction to core functionality</li> </ul>"},{"location":"examples/#use-cases","title":"Use Cases","text":"<ul> <li>HR Onboarding - Track employee facts over time</li> <li>News Analysis - Extract facts from news articles</li> </ul>"},{"location":"examples/#common-patterns","title":"Common Patterns","text":""},{"location":"examples/#ingest-and-extract","title":"Ingest and Extract","text":"<pre><code>facts = FactDb.new\n\n# Ingest content\nsource = facts.ingest(document_text, type: :document)\n\n# Extract facts\nextracted = facts.extract_facts(source.id, extractor: :llm)\n</code></pre>"},{"location":"examples/#query-current-state","title":"Query Current State","text":"<pre><code># What do we know about Paula now?\ncurrent = facts.current_facts_for(paula.id)\n</code></pre>"},{"location":"examples/#historical-query","title":"Historical Query","text":"<pre><code># What did we know on a specific date?\nhistorical = facts.facts_at(Date.parse(\"2023-06-15\"), entity: paula.id)\n</code></pre>"},{"location":"examples/#timeline","title":"Timeline","text":"<pre><code># Build complete timeline\ntimeline = facts.timeline_for(paula.id)\ntimeline.each do |fact|\n  puts \"#{fact.valid_at}: #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/#entity-resolution","title":"Entity Resolution","text":"<pre><code># Resolve names to entities\nentity = facts.resolve_entity(\"Paula Chen\", type: :person)\n</code></pre>"},{"location":"examples/#batch-processing","title":"Batch Processing","text":"<pre><code># Process multiple documents\nresults = facts.batch_extract(source_ids, parallel: true)\n</code></pre>"},{"location":"examples/basic-usage/","title":"Basic Usage","text":"<p>A simple introduction to FactDb's core functionality.</p>"},{"location":"examples/basic-usage/#setup","title":"Setup","text":"<pre><code>require 'fact_db'\n\n# Configure\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n\n# Create facts instance\nfacts = FactDb.new\n</code></pre>"},{"location":"examples/basic-usage/#ingest-content","title":"Ingest Content","text":"<pre><code># Ingest an email\nemail = facts.ingest(\n  &lt;&lt;~TEXT,\n    Hi team,\n\n    I'm excited to announce that Paula Chen has accepted our offer\n    to join Microsoft as Principal Engineer starting January 10, 2024.\n\n    She'll be part of the Platform team reporting to Sarah Johnson.\n\n    Best,\n    HR\n  TEXT\n  type: :email,\n  title: \"New Hire Announcement - Paula Chen\",\n  captured_at: Time.current\n)\n\nputs \"Ingested content ID: #{email.id}\"\n</code></pre>"},{"location":"examples/basic-usage/#create-entities","title":"Create Entities","text":"<pre><code># Create people\npaula = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\"]\n)\n\nsarah = facts.entity_service.create(\n  \"Sarah Johnson\",\n  type: :person,\n  aliases: [\"Sarah\"]\n)\n\n# Create organization\nmicrosoft = facts.entity_service.create(\n  \"Microsoft\",\n  type: :organization,\n  aliases: [\"MS\", \"MSFT\"]\n)\n\nplatform_team = facts.entity_service.create(\n  \"Platform Team\",\n  type: :organization\n)\n\nputs \"Created entities: Paula, Sarah, Microsoft, Platform Team\"\n</code></pre>"},{"location":"examples/basic-usage/#extract-facts-manually","title":"Extract Facts Manually","text":"<pre><code># Create facts with explicit links\nfact1 = facts.fact_service.create(\n  \"Paula Chen joined Microsoft as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: microsoft, role: \"organization\", text: \"Microsoft\" }\n  ],\n  sources: [\n    { source: email, type: \"primary\" }\n  ]\n)\n\nfact2 = facts.fact_service.create(\n  \"Paula Chen reports to Sarah Johnson\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: sarah, role: \"object\", text: \"Sarah Johnson\" }\n  ],\n  sources: [\n    { source: email, type: \"primary\" }\n  ]\n)\n\nfact3 = facts.fact_service.create(\n  \"Paula Chen is on the Platform Team\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: platform_team, role: \"organization\", text: \"Platform Team\" }\n  ],\n  sources: [\n    { source: email, type: \"primary\" }\n  ]\n)\n\nputs \"Created #{3} facts\"\n</code></pre>"},{"location":"examples/basic-usage/#extract-facts-with-llm","title":"Extract Facts with LLM","text":"<pre><code># Alternative: let LLM extract facts\nextracted = facts.extract_facts(email.id, extractor: :llm)\n\nputs \"LLM extracted #{extracted.count} facts:\"\nextracted.each do |fact|\n  puts \"  - #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/basic-usage/#query-facts","title":"Query Facts","text":"<pre><code># Current facts about Paula\nputs \"\\nCurrent facts about Paula:\"\nfacts.current_facts_for(paula.id).each do |fact|\n  puts \"  - #{fact.text}\"\nend\n\n# Facts about Microsoft\nputs \"\\nFacts about Microsoft:\"\nfacts.query_facts(entity: microsoft.id).each do |fact|\n  puts \"  - #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/basic-usage/#resolve-entity","title":"Resolve Entity","text":"<pre><code># Resolve a name\nresolved = facts.resolve_entity(\"Paula\")\nputs \"\\n'Paula' resolves to: #{resolved&amp;.name}\"\n\n# Type-constrained resolution\nperson = facts.resolve_entity(\"Paula\", type: :person)\nputs \"'Paula' as person: #{person&amp;.name}\"\n</code></pre>"},{"location":"examples/basic-usage/#update-facts-supersession","title":"Update Facts (Supersession)","text":"<pre><code># Paula gets promoted\nnew_fact = facts.fact_service.resolver.supersede(\n  fact1.id,\n  \"Paula Chen is Senior Principal Engineer at Microsoft\",\n  valid_at: Date.parse(\"2024-06-01\")\n)\n\nputs \"\\nSuperseded fact:\"\nputs \"  Old: #{fact1.reload.text} (#{fact1.status})\"\nputs \"  New: #{new_fact.text} (#{new_fact.status})\"\n</code></pre>"},{"location":"examples/basic-usage/#timeline","title":"Timeline","text":"<pre><code># Build timeline\nputs \"\\nPaula's timeline:\"\nfacts.timeline_for(paula.id).each do |fact|\n  valid = fact.invalid_at ? \"#{fact.valid_at} - #{fact.invalid_at}\" : \"#{fact.valid_at} - present\"\n  puts \"  #{valid}: #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/basic-usage/#historical-query","title":"Historical Query","text":"<pre><code># What did we know before promotion?\nputs \"\\nFacts about Paula on March 1, 2024:\"\nfacts.facts_at(Date.parse(\"2024-03-01\"), entity: paula.id).each do |fact|\n  puts \"  - #{fact.text}\"\nend\n\n# What do we know after promotion?\nputs \"\\nFacts about Paula on July 1, 2024:\"\nfacts.facts_at(Date.parse(\"2024-07-01\"), entity: paula.id).each do |fact|\n  puts \"  - #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/basic-usage/#complete-script","title":"Complete Script","text":"<pre><code>#!/usr/bin/env ruby\nrequire 'fact_db'\n\n# Setup\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL'] || 'postgresql://localhost/fact_db'\nend\n\nfacts = FactDb.new\n\n# Ingest\nsource = facts.ingest(\"Paula joined Microsoft on Jan 10, 2024\", type: :note)\n\n# Create entities\npaula = facts.entity_service.create(\"Paula\", type: :person)\nmicrosoft = facts.entity_service.create(\"Microsoft\", type: :organization)\n\n# Create fact\nfact = facts.fact_service.create(\n  \"Paula joined Microsoft\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula\" },\n    { entity: microsoft, role: \"organization\", text: \"Microsoft\" }\n  ],\n  sources: [{ source: source, type: \"primary\" }]\n)\n\n# Query\nputs \"Current facts about Paula:\"\nfacts.current_facts_for(paula.id).each { |f| puts \"  - #{f.text}\" }\n</code></pre>"},{"location":"examples/hr-onboarding/","title":"HR Onboarding Example","text":"<p>Track employee lifecycle events - hiring, promotions, transfers, and departures.</p>"},{"location":"examples/hr-onboarding/#scenario","title":"Scenario","text":"<p>An HR system that tracks employee facts over time, maintaining a complete audit trail of employment events.</p>"},{"location":"examples/hr-onboarding/#setup","title":"Setup","text":"<pre><code>require 'fact_db'\n\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n\nfacts = FactDb.new\n</code></pre>"},{"location":"examples/hr-onboarding/#create-organization-structure","title":"Create Organization Structure","text":"<pre><code># Company\nacme = facts.entity_service.create(\n  \"Acme Corporation\",\n  type: :organization,\n  aliases: [\"Acme\", \"Acme Corp\"]\n)\n\n# Departments\nengineering = facts.entity_service.create(\n  \"Engineering Department\",\n  type: :organization,\n  aliases: [\"Engineering\", \"Eng\"]\n)\n\nsales = facts.entity_service.create(\n  \"Sales Department\",\n  type: :organization,\n  aliases: [\"Sales\"]\n)\n\n# Locations\nhq = facts.entity_service.create(\n  \"Headquarters\",\n  type: :place,\n  aliases: [\"HQ\", \"Main Office\"],\n  metadata: { address: \"123 Main St, San Francisco, CA\" }\n)\n</code></pre>"},{"location":"examples/hr-onboarding/#track-hiring-event","title":"Track Hiring Event","text":"<pre><code># Ingest offer letter\noffer_letter = facts.ingest(\n  &lt;&lt;~TEXT,\n    Dear Paula Chen,\n\n    We are pleased to offer you the position of Software Engineer\n    at Acme Corporation, starting March 1, 2022.\n\n    Your starting salary will be $120,000 per year.\n    You will report to John Smith, Engineering Manager.\n\n    Location: Headquarters, San Francisco\n  TEXT\n  type: :document,\n  title: \"Offer Letter - Paula Chen\",\n  captured_at: Date.parse(\"2022-02-15\")\n)\n\n# Create employee\npaula = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\"],\n  metadata: { employee_id: \"E001\" }\n)\n\njohn = facts.entity_service.create(\n  \"John Smith\",\n  type: :person,\n  aliases: [\"John\"],\n  metadata: { employee_id: \"M001\" }\n)\n\n# Create employment facts\nfacts.fact_service.create(\n  \"Paula Chen is employed at Acme Corporation\",\n  valid_at: Date.parse(\"2022-03-01\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: acme, role: \"organization\", text: \"Acme Corporation\" }\n  ],\n  sources: [{ source: offer_letter, type: \"primary\" }]\n)\n\nfacts.fact_service.create(\n  \"Paula Chen's title is Software Engineer\",\n  valid_at: Date.parse(\"2022-03-01\"),\n  mentions: [{ entity: paula, role: \"subject\", text: \"Paula Chen\" }],\n  sources: [{ source: offer_letter, type: \"primary\" }]\n)\n\nfacts.fact_service.create(\n  \"Paula Chen reports to John Smith\",\n  valid_at: Date.parse(\"2022-03-01\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: john, role: \"object\", text: \"John Smith\" }\n  ],\n  sources: [{ source: offer_letter, type: \"primary\" }]\n)\n\nfacts.fact_service.create(\n  \"Paula Chen works in Engineering Department\",\n  valid_at: Date.parse(\"2022-03-01\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: engineering, role: \"organization\", text: \"Engineering\" }\n  ],\n  sources: [{ source: offer_letter, type: \"primary\" }]\n)\n</code></pre>"},{"location":"examples/hr-onboarding/#track-promotion","title":"Track Promotion","text":"<pre><code># Ingest promotion letter\npromotion = facts.ingest(\n  &lt;&lt;~TEXT,\n    Dear Paula,\n\n    Congratulations! Effective January 15, 2023, you have been\n    promoted to Senior Software Engineer.\n\n    Your new salary will be $145,000 per year.\n  TEXT\n  type: :document,\n  title: \"Promotion Letter - Paula Chen\",\n  captured_at: Date.parse(\"2023-01-10\")\n)\n\n# Supersede title fact\ntitle_fact = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .search_text(\"title\")\n  .canonical\n  .first\n\nfacts.fact_service.resolver.supersede(\n  title_fact.id,\n  \"Paula Chen's title is Senior Software Engineer\",\n  valid_at: Date.parse(\"2023-01-15\")\n)\n</code></pre>"},{"location":"examples/hr-onboarding/#track-transfer","title":"Track Transfer","text":"<pre><code># Ingest transfer notice\ntransfer = facts.ingest(\n  &lt;&lt;~TEXT,\n    Effective July 1, 2023, Paula Chen will transfer from\n    Engineering to Sales as Sales Engineer, reporting to\n    Maria Garcia.\n  TEXT\n  type: :document,\n  title: \"Transfer Notice - Paula Chen\",\n  captured_at: Date.parse(\"2023-06-15\")\n)\n\nmaria = facts.entity_service.create(\n  \"Maria Garcia\",\n  type: :person,\n  metadata: { employee_id: \"M002\" }\n)\n\n# Supersede department fact\ndept_fact = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .search_text(\"Department\")\n  .canonical\n  .first\n\nfacts.fact_service.resolver.supersede(\n  dept_fact.id,\n  \"Paula Chen works in Sales Department\",\n  valid_at: Date.parse(\"2023-07-01\")\n)\n\n# Supersede manager fact\nmanager_fact = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .search_text(\"reports to\")\n  .canonical\n  .first\n\nfacts.fact_service.resolver.supersede(\n  manager_fact.id,\n  \"Paula Chen reports to Maria Garcia\",\n  valid_at: Date.parse(\"2023-07-01\")\n)\n\n# Supersede title\ntitle_fact = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .search_text(\"title\")\n  .canonical\n  .first\n\nfacts.fact_service.resolver.supersede(\n  title_fact.id,\n  \"Paula Chen's title is Sales Engineer\",\n  valid_at: Date.parse(\"2023-07-01\")\n)\n</code></pre>"},{"location":"examples/hr-onboarding/#query-employment-history","title":"Query Employment History","text":"<pre><code># Complete timeline\nputs \"Paula Chen's Employment Timeline:\"\nputs \"=\" * 50\n\nfacts.timeline_for(paula.id).each do |fact|\n  valid = fact.invalid_at ?\n    \"#{fact.valid_at.to_date} - #{fact.invalid_at.to_date}\" :\n    \"#{fact.valid_at.to_date} - present\"\n\n  status = fact.superseded? ? \" [superseded]\" : \"\"\n  puts \"#{valid}: #{fact.text}#{status}\"\nend\n</code></pre> <p>Output: <pre><code>Paula Chen's Employment Timeline:\n==================================================\n2022-03-01 - present: Paula Chen is employed at Acme Corporation\n2022-03-01 - 2023-01-15: Paula Chen's title is Software Engineer [superseded]\n2023-01-15 - 2023-07-01: Paula Chen's title is Senior Software Engineer [superseded]\n2023-07-01 - present: Paula Chen's title is Sales Engineer\n2022-03-01 - 2023-07-01: Paula Chen works in Engineering Department [superseded]\n2023-07-01 - present: Paula Chen works in Sales Department\n2022-03-01 - 2023-07-01: Paula Chen reports to John Smith [superseded]\n2023-07-01 - present: Paula Chen reports to Maria Garcia\n</code></pre></p>"},{"location":"examples/hr-onboarding/#point-in-time-queries","title":"Point-in-Time Queries","text":"<pre><code># What was Paula's status on different dates?\n\ndates = [\n  Date.parse(\"2022-06-01\"),\n  Date.parse(\"2023-03-01\"),\n  Date.parse(\"2023-10-01\")\n]\n\ndates.each do |date|\n  puts \"\\nPaula's status on #{date}:\"\n  facts.facts_at(date, entity: paula.id).each do |fact|\n    puts \"  - #{fact.text}\"\n  end\nend\n</code></pre>"},{"location":"examples/hr-onboarding/#generate-employment-report","title":"Generate Employment Report","text":"<pre><code>def employment_report(facts, employee_id)\n  employee = FactDb::Models::Entity.find(employee_id)\n  current = facts.current_facts_for(employee_id)\n\n  report = {\n    name: employee.name,\n    current_status: {},\n    history: []\n  }\n\n  # Current status\n  current.each do |fact|\n    if fact.text.include?(\"title is\")\n      report[:current_status][:title] = fact.text.split(\"title is \").last\n    elsif fact.text.include?(\"works in\")\n      report[:current_status][:department] = fact.text.split(\"works in \").last\n    elsif fact.text.include?(\"reports to\")\n      report[:current_status][:manager] = fact.text.split(\"reports to \").last\n    end\n  end\n\n  # Employment history\n  report[:history] = facts.timeline_for(employee_id).map do |fact|\n    {\n      fact: fact.text,\n      from: fact.valid_at,\n      to: fact.invalid_at,\n      status: fact.status\n    }\n  end\n\n  report\nend\n\nreport = employment_report(facts, paula.id)\nputs JSON.pretty_generate(report)\n</code></pre>"},{"location":"examples/news-analysis/","title":"News Analysis Example","text":"<p>Extract and track facts from news articles over time.</p>"},{"location":"examples/news-analysis/#scenario","title":"Scenario","text":"<p>A news monitoring system that extracts facts from articles and tracks how information about companies and people changes over time.</p>"},{"location":"examples/news-analysis/#setup","title":"Setup","text":"<pre><code>require 'fact_db'\n\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n\nfacts = FactDb.new\n</code></pre>"},{"location":"examples/news-analysis/#ingest-news-articles","title":"Ingest News Articles","text":"<pre><code># Article 1: CEO Announcement\narticle1 = facts.ingest(\n  &lt;&lt;~TEXT,\n    TechCorp Appoints New CEO\n\n    San Francisco, Jan 15, 2024 - TechCorp announced today that\n    Jane Williams has been appointed as Chief Executive Officer,\n    effective immediately. Williams previously served as COO at\n    InnovateTech for 8 years.\n\n    \"We are thrilled to welcome Jane to lead TechCorp into its\n    next chapter,\" said Board Chairman Robert Chen.\n\n    Williams succeeds Michael Johnson, who is retiring after\n    15 years at the helm.\n  TEXT\n  type: :article,\n  title: \"TechCorp Appoints New CEO\",\n  source_uri: \"https://news.example.com/techcorp-new-ceo\",\n  captured_at: Date.parse(\"2024-01-15\"),\n  metadata: {\n    source: \"Tech News Daily\",\n    author: \"Sarah Reporter\",\n    category: \"Business\"\n  }\n)\n\n# Article 2: Earnings Report\narticle2 = facts.ingest(\n  &lt;&lt;~TEXT,\n    TechCorp Reports Record Q4 Earnings\n\n    San Francisco, Feb 1, 2024 - TechCorp reported quarterly\n    revenue of $5.2 billion, up 23% year-over-year. Net income\n    reached $800 million.\n\n    \"Our cloud division continues to drive growth,\" said CEO\n    Jane Williams in her first earnings call since taking over.\n\n    The company also announced plans to acquire DataFlow Inc\n    for $1.2 billion, expected to close in Q2 2024.\n  TEXT\n  type: :article,\n  title: \"TechCorp Reports Record Q4 Earnings\",\n  source_uri: \"https://news.example.com/techcorp-q4-earnings\",\n  captured_at: Date.parse(\"2024-02-01\"),\n  metadata: { source: \"Financial Times\", category: \"Earnings\" }\n)\n\n# Article 3: Acquisition Update\narticle3 = facts.ingest(\n  &lt;&lt;~TEXT,\n    TechCorp-DataFlow Deal Falls Through\n\n    San Francisco, Apr 15, 2024 - TechCorp announced it has\n    terminated its planned acquisition of DataFlow Inc, citing\n    regulatory concerns.\n\n    \"After careful consideration, we have decided not to proceed\n    with the acquisition,\" said TechCorp CEO Jane Williams.\n  TEXT\n  type: :article,\n  title: \"TechCorp-DataFlow Deal Falls Through\",\n  source_uri: \"https://news.example.com/techcorp-dataflow-cancelled\",\n  captured_at: Date.parse(\"2024-04-15\"),\n  metadata: { source: \"Business Wire\", category: \"M&amp;A\" }\n)\n</code></pre>"},{"location":"examples/news-analysis/#extract-facts-with-llm","title":"Extract Facts with LLM","text":"<pre><code># Process all articles\n[article1, article2, article3].each do |article|\n  puts \"Processing: #{article.title}\"\n  extracted = facts.extract_facts(article.id, extractor: :llm)\n  puts \"  Extracted #{extracted.count} facts\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#review-extracted-entities","title":"Review Extracted Entities","text":"<pre><code># List all extracted entities\nputs \"\\nExtracted Entities:\"\nFactDb::Models::Entity.all.each do |entity|\n  puts \"  #{entity.name} (#{entity.type})\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#query-facts-by-topic","title":"Query Facts by Topic","text":"<pre><code># CEO-related facts\nputs \"\\nCEO Facts:\"\nfacts.query_facts(topic: \"CEO\").each do |fact|\n  puts \"  #{fact.valid_at.to_date}: #{fact.text}\"\nend\n\n# Acquisition facts\nputs \"\\nAcquisition Facts:\"\nfacts.query_facts(topic: \"acquisition\").each do |fact|\n  puts \"  #{fact.valid_at.to_date}: #{fact.text}\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#track-entity-over-time","title":"Track Entity Over Time","text":"<pre><code># Find TechCorp entity\ntechcorp = facts.resolve_entity(\"TechCorp\", type: :organization)\n\n# Timeline of TechCorp facts\nputs \"\\nTechCorp Timeline:\"\nfacts.timeline_for(techcorp.id).each do |fact|\n  source = fact.fact_sources.first&amp;.source&amp;.title || \"Unknown\"\n  puts \"  #{fact.valid_at.to_date}: #{fact.text}\"\n  puts \"    Source: #{source}\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#handle-superseded-information","title":"Handle Superseded Information","text":"<pre><code># The acquisition fact from article2 should be superseded by article3\n\n# Find the original acquisition fact\nacquisition_fact = FactDb::Models::Fact\n  .search_text(\"acquire DataFlow\")\n  .canonical\n  .first\n\nif acquisition_fact\n  # Supersede with cancelled status\n  facts.fact_service.resolver.supersede(\n    acquisition_fact.id,\n    \"TechCorp cancelled its planned acquisition of DataFlow Inc\",\n    valid_at: Date.parse(\"2024-04-15\")\n  )\n\n  puts \"\\nAcquisition status updated:\"\n  puts \"  Original: #{acquisition_fact.reload.text} (#{acquisition_fact.status})\"\n  puts \"  Updated: #{acquisition_fact.superseded_by.text}\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#corroborate-facts","title":"Corroborate Facts","text":"<pre><code># If multiple articles confirm the same fact\nceo_facts = FactDb::Models::Fact\n  .search_text(\"Jane Williams CEO\")\n  .canonical\n  .to_a\n\nif ceo_facts.count &gt; 1\n  primary = ceo_facts.first\n  ceo_facts[1..].each do |corroborating|\n    facts.fact_service.resolver.corroborate(primary.id, corroborating.id)\n  end\n  puts \"\\nCEO fact corroborated by #{ceo_facts.count} sources\"\nend\n</code></pre>"},{"location":"examples/news-analysis/#generate-company-report","title":"Generate Company Report","text":"<pre><code>def company_report(facts, company_name)\n  company = facts.resolve_entity(company_name, type: :organization)\n  return nil unless company\n\n  current_facts = facts.current_facts_for(company.id)\n\n  {\n    company: company.name,\n    current_facts: current_facts.map(&amp;:text),\n    leadership: extract_leadership(current_facts),\n    timeline: facts.timeline_for(company.id).map { |f|\n      {\n        date: f.valid_at,\n        fact: f.text,\n        source: f.fact_sources.first&amp;.source&amp;.title\n      }\n    }\n  }\nend\n\ndef extract_leadership(facts)\n  leadership = {}\n  facts.each do |fact|\n    if fact.text =~ /CEO/\n      leadership[:ceo] = fact.entity_mentions.find { |m| m.mention_role == \"subject\" }&amp;.entity&amp;.name\n    end\n  end\n  leadership\nend\n\nreport = company_report(facts, \"TechCorp\")\nputs JSON.pretty_generate(report)\n</code></pre>"},{"location":"examples/news-analysis/#batch-process-news-feed","title":"Batch Process News Feed","text":"<pre><code>def process_news_feed(facts, articles)\n  source_ids = articles.map do |article|\n    source = facts.ingest(\n      article[:text],\n      type: :article,\n      title: article[:title],\n      source_uri: article[:url],\n      captured_at: article[:published_at]\n    )\n    source.id\n  end\n\n  # Parallel extraction\n  results = facts.batch_extract(source_ids, extractor: :llm)\n\n  {\n    processed: results.count,\n    successful: results.count { |r| r[:error].nil? },\n    total_facts: results.sum { |r| r[:facts].count }\n  }\nend\n\n# Example usage\nnews_feed = [\n  { title: \"Article 1\", text: \"...\", url: \"...\", published_at: Time.now },\n  { title: \"Article 2\", text: \"...\", url: \"...\", published_at: Time.now }\n]\n\nstats = process_news_feed(facts, news_feed)\nputs \"Processed #{stats[:processed]} articles, extracted #{stats[:total_facts]} facts\"\n</code></pre>"},{"location":"examples/news-analysis/#monitor-specific-topics","title":"Monitor Specific Topics","text":"<pre><code>def monitor_topic(facts, topic, since: 1.week.ago)\n  matching = FactDb::Models::Fact\n    .search_text(topic)\n    .where(\"created_at &gt; ?\", since)\n    .order(created_at: :desc)\n\n  {\n    topic: topic,\n    new_facts: matching.count,\n    facts: matching.map { |f|\n      {\n        text: f.text,\n        date: f.valid_at,\n        source: f.fact_sources.first&amp;.source&amp;.title,\n        entities: f.entity_mentions.map { |m| m.entity.name }\n      }\n    }\n  }\nend\n\n# Monitor acquisitions\nacquisition_updates = monitor_topic(facts, \"acquisition\")\nputs \"Recent acquisition news: #{acquisition_updates[:new_facts]} facts\"\n</code></pre>"},{"location":"getting-started/","title":"Getting Started","text":"<p>This section will help you get FactDb up and running in your Ruby application.</p>"},{"location":"getting-started/#prerequisites","title":"Prerequisites","text":"<p>Before installing FactDb, ensure you have:</p> <ul> <li>Ruby 3.0+ - FactDb requires Ruby 3.0 or later</li> <li>PostgreSQL 14+ - With the pgvector extension installed</li> <li>Bundler - For dependency management</li> </ul>"},{"location":"getting-started/#quick-navigation","title":"Quick Navigation","text":"<ul> <li> <p> Installation</p> <p>Install FactDb and its dependencies</p> <p> Installation Guide</p> </li> <li> <p> Quick Start</p> <p>Get up and running in 5 minutes</p> <p> Quick Start</p> </li> <li> <p> Database Setup</p> <p>Configure PostgreSQL and run migrations</p> <p> Database Setup</p> </li> </ul>"},{"location":"getting-started/#overview","title":"Overview","text":"<p>Getting started with FactDb involves three steps:</p> <ol> <li>Install the gem - Add FactDb to your Gemfile</li> <li>Set up the database - Create tables and enable pgvector</li> <li>Configure - Set database URL and optional LLM settings</li> </ol> <p>Once configured, you can start ingesting content and extracting facts:</p> <pre><code>require 'fact_db'\n\n# Configure\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\nend\n\n# Create a facts instance\nfacts = FactDb.new\n\n# Ingest content\nsource = facts.ingest(\"Important information...\", type: :document)\n\n# Extract and query facts\nextracted = facts.extract_facts(source.id)\n</code></pre> <p>Continue to the Installation Guide to begin.</p>"},{"location":"getting-started/database-setup/","title":"Database Setup","text":"<p>FactDb uses PostgreSQL with the pgvector extension for storing content, entities, and facts with semantic search capabilities.</p>"},{"location":"getting-started/database-setup/#create-database","title":"Create Database","text":"<pre><code>createdb fact_db\n</code></pre>"},{"location":"getting-started/database-setup/#enable-pgvector","title":"Enable pgvector","text":"<p>Connect to your database and enable the extension:</p> <pre><code>CREATE EXTENSION IF NOT EXISTS vector;\n</code></pre>"},{"location":"getting-started/database-setup/#run-migrations","title":"Run Migrations","text":"<p>FactDb provides migrations that create all necessary tables:</p> <pre><code>require 'fact_db'\n\nFactDb.configure do |config|\n  config.database.url = \"postgresql://localhost/fact_db\"\nend\n\nFactDb::Database.migrate!\n</code></pre>"},{"location":"getting-started/database-setup/#schema-overview","title":"Schema Overview","text":"<p>The migrations create six tables:</p>"},{"location":"getting-started/database-setup/#sources","title":"sources","text":"<p>Stores immutable source content.</p> Column Type Description id bigint Primary key content_hash string SHA256 hash for deduplication type string Type (email, document, article) content text Original source content title string Optional title source_uri string Original location metadata jsonb Additional metadata embedding vector(1536) Semantic search vector captured_at timestamptz When content was captured"},{"location":"getting-started/database-setup/#entities","title":"entities","text":"<p>Stores resolved identities.</p> Column Type Description id bigint Primary key name string Authoritative name type string person, organization, place, etc. resolution_status string unresolved, resolved, merged canonical_id bigint Points to canonical entity if merged metadata jsonb Additional attributes embedding vector(1536) Semantic search vector"},{"location":"getting-started/database-setup/#entity_aliases","title":"entity_aliases","text":"<p>Stores alternative names for entities.</p> Column Type Description id bigint Primary key entity_id bigint Foreign key to entities name string Alternative name type string nickname, abbreviation, etc. confidence float Match confidence (0-1)"},{"location":"getting-started/database-setup/#facts","title":"facts","text":"<p>Stores temporal assertions.</p> Column Type Description id bigint Primary key text text The assertion digest string SHA256 digest for deduplication valid_at timestamptz When fact became true invalid_at timestamptz When fact stopped being true status string canonical, superseded, corroborated, synthesized superseded_by_id bigint Points to replacing fact derived_from_ids bigint[] Source facts for synthesized corroborated_by_ids bigint[] Corroborating facts confidence float Extraction confidence extraction_method string manual, llm, rule_based metadata jsonb Additional data embedding vector(1536) Semantic search vector"},{"location":"getting-started/database-setup/#entity_mentions","title":"entity_mentions","text":"<p>Links facts to entities.</p> Column Type Description id bigint Primary key fact_id bigint Foreign key to facts entity_id bigint Foreign key to entities mention_text string Text that mentioned entity mention_role string subject, object, location, etc. confidence float Resolution confidence"},{"location":"getting-started/database-setup/#fact_sources","title":"fact_sources","text":"<p>Links facts to source content.</p> Column Type Description id bigint Primary key fact_id bigint Foreign key to facts source_id bigint Foreign key to sources source_type string primary, supporting, contradicting excerpt text Relevant text excerpt confidence float Source confidence"},{"location":"getting-started/database-setup/#indexes","title":"Indexes","text":"<p>The migrations create indexes for:</p> <ul> <li>Content hash (unique)</li> <li>Content type</li> <li>Full-text search on content</li> <li>Entity name</li> <li>Entity type</li> <li>Fact status</li> <li>Temporal range queries (valid_at, invalid_at)</li> <li>HNSW indexes for vector similarity search</li> </ul>"},{"location":"getting-started/database-setup/#custom-migration","title":"Custom Migration","text":"<p>If you need to integrate with an existing database or customize the schema:</p> <pre><code># Copy migration files to your project\nFileUtils.cp_r(\n  FactDb.root.join('db/migrate'),\n  Rails.root.join('db/migrate')\n)\n\n# Or run standalone\nFactDb::Database.migrate!(\n  migrations_path: '/custom/path/to/migrations'\n)\n</code></pre>"},{"location":"getting-started/database-setup/#connection-pool","title":"Connection Pool","text":"<p>Configure the connection pool for your workload:</p> <pre><code>FactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\n  config.database.pool_size = 10  # Default: 5\n  config.database.timeout = 60_000  # Default: 30000ms\nend\n</code></pre> <p>Or via environment variables:</p> <pre><code>export FDB_DATABASE__URL=\"postgresql://localhost/fact_db\"\nexport FDB_DATABASE__POOL_SIZE=10\nexport FDB_DATABASE__TIMEOUT=60000\n</code></pre>"},{"location":"getting-started/database-setup/#next-steps","title":"Next Steps","text":"<ul> <li>Quick Start - Start using FactDb</li> <li>Configuration - Full configuration options</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#requirements","title":"Requirements","text":"<ul> <li>Ruby &gt;= 3.0.0</li> <li>PostgreSQL &gt;= 14 with pgvector extension</li> <li>Bundler</li> </ul>"},{"location":"getting-started/installation/#install-the-gem","title":"Install the Gem","text":"<p>Add FactDb to your Gemfile:</p> <pre><code>gem 'fact_db'\n</code></pre> <p>Then install:</p> <pre><code>bundle install\n</code></pre> <p>Or install directly:</p> <pre><code>gem install fact_db\n</code></pre>"},{"location":"getting-started/installation/#install-pgvector","title":"Install pgvector","text":"<p>FactDb uses pgvector for semantic search. Install the PostgreSQL extension:</p> macOS (Homebrew)Ubuntu/DebianFrom Source <pre><code>brew install pgvector\n</code></pre> <pre><code>sudo apt install postgresql-14-pgvector\n</code></pre> <pre><code>git clone https://github.com/pgvector/pgvector.git\ncd pgvector\nmake\nsudo make install\n</code></pre> <p>Then enable the extension in your database:</p> <pre><code>CREATE EXTENSION IF NOT EXISTS vector;\n</code></pre>"},{"location":"getting-started/installation/#optional-dependencies","title":"Optional Dependencies","text":""},{"location":"getting-started/installation/#llm-extraction","title":"LLM Extraction","text":"<p>For LLM-powered fact extraction, add the ruby_llm gem:</p> <pre><code>gem 'ruby_llm'\n</code></pre>"},{"location":"getting-started/installation/#async-processing","title":"Async Processing","text":"<p>For parallel pipeline processing with async fibers:</p> <pre><code>gem 'async', '~&gt; 2.0'\n</code></pre>"},{"location":"getting-started/installation/#verify-installation","title":"Verify Installation","text":"<p>Create a simple test script:</p> <pre><code>require 'fact_db'\n\nputs \"FactDb version: #{FactDb::VERSION}\"\nputs \"Installation successful!\"\n</code></pre> <p>Run it:</p> <pre><code>ruby test_install.rb\n</code></pre>"},{"location":"getting-started/installation/#next-steps","title":"Next Steps","text":"<ul> <li>Database Setup - Configure your database</li> <li>Quick Start - Start using FactDb</li> </ul>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>Get FactDb running in 5 minutes.</p>"},{"location":"getting-started/quick-start/#1-configure","title":"1. Configure","text":"<p>Create a configuration file or use environment variables:</p> Environment VariablesYAML ConfigRuby Block <pre><code>export FDB_DATABASE__URL=\"postgresql://localhost/fact_db\"\nexport FDB_LLM__PROVIDER=\"openai\"\nexport FDB_LLM__API_KEY=\"sk-...\"\n</code></pre> <pre><code># config/fact_db.yml\ndatabase:\n  url: postgresql://localhost/fact_db\n\nllm:\n  provider: openai\n  api_key: &lt;%= ENV['OPENAI_API_KEY'] %&gt;\n</code></pre> <pre><code>FactDb.configure do |config|\n  config.database.url = \"postgresql://localhost/fact_db\"\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n</code></pre>"},{"location":"getting-started/quick-start/#2-set-up-database","title":"2. Set Up Database","text":"<p>Run the migrations:</p> <pre><code>require 'fact_db'\n\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\nend\n\n# Run migrations\nFactDb::Database.migrate!\n</code></pre>"},{"location":"getting-started/quick-start/#3-create-your-first-facts-instance","title":"3. Create Your First Facts Instance","text":"<pre><code>require 'fact_db'\n\nfacts = FactDb.new\n</code></pre>"},{"location":"getting-started/quick-start/#4-ingest-content","title":"4. Ingest Content","text":"<pre><code># Ingest an email\nsource = facts.ingest(\n  \"Hi team, Paula Chen has accepted our offer and will join as Principal Engineer starting January 10, 2024. She'll be reporting to Sarah in the Platform team.\",\n  type: :email,\n  title: \"New Hire Announcement\",\n  captured_at: Time.current\n)\n\nputs \"Ingested source: #{source.id}\"\n</code></pre>"},{"location":"getting-started/quick-start/#5-create-entities","title":"5. Create Entities","text":"<pre><code># Create entities for people and organizations\npaula = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\", \"P. Chen\"]\n)\n\nsarah = facts.entity_service.create(\n  \"Sarah Johnson\",\n  type: :person,\n  aliases: [\"Sarah\"]\n)\n\nplatform_team = facts.entity_service.create(\n  \"Platform Team\",\n  type: :organization\n)\n</code></pre>"},{"location":"getting-started/quick-start/#6-extract-facts","title":"6. Extract Facts","text":""},{"location":"getting-started/quick-start/#manual-extraction","title":"Manual Extraction","text":"<pre><code>fact = facts.fact_service.create(\n  \"Paula Chen joined as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" }\n  ],\n  sources: [\n    { source: source, type: \"primary\" }\n  ]\n)\n</code></pre>"},{"location":"getting-started/quick-start/#llm-extraction","title":"LLM Extraction","text":"<pre><code># Extract facts automatically using LLM\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  puts \"Extracted: #{fact.text}\"\n  puts \"  Valid from: #{fact.valid_at}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#7-query-facts","title":"7. Query Facts","text":"<pre><code># Get current facts about Paula\ncurrent = facts.current_facts_for(paula.id)\ncurrent.each { |f| puts f.text }\n\n# Get facts valid at a specific date\nhistorical = facts.facts_at(\n  Date.parse(\"2023-12-01\"),\n  entity: paula.id\n)\n\n# Search by topic\nteam_facts = facts.query_facts(topic: \"Platform Team\")\n</code></pre>"},{"location":"getting-started/quick-start/#8-build-timelines","title":"8. Build Timelines","text":"<pre><code>timeline = facts.timeline_for(paula.id)\n\ntimeline.each do |entry|\n  puts \"#{entry[:date]}: #{entry[:fact].text}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#complete-example","title":"Complete Example","text":"<pre><code>require 'fact_db'\n\n# Configure\nFactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n\n# Create facts instance\nfacts = FactDb.new\n\n# Ingest content\nsource = facts.ingest(\n  \"Paula Chen joined Microsoft as Principal Engineer on January 10, 2024.\",\n  type: :announcement,\n  captured_at: Time.current\n)\n\n# Create entities\npaula = facts.entity_service.create(\"Paula Chen\", type: :person)\nmicrosoft = facts.entity_service.create(\"Microsoft\", type: :organization)\n\n# Extract facts via LLM\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\n# Query\nputs \"Current facts about Paula:\"\nfacts.current_facts_for(paula.id).each do |fact|\n  puts \"  - #{fact.text}\"\nend\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<ul> <li>Configuration Guide - Detailed configuration options</li> <li>Ingesting Content - Learn about content types</li> <li>LLM Integration - Set up LLM providers</li> </ul>"},{"location":"guides/","title":"Guides","text":"<p>Practical guides for using FactDb in your applications.</p>"},{"location":"guides/#configuration","title":"Configuration","text":"<ul> <li>Configuration - Configure database, LLM, and extraction settings</li> </ul>"},{"location":"guides/#working-with-data","title":"Working with Data","text":"<ul> <li>Ingesting Content - Import documents, emails, and other content</li> <li>Extracting Facts - Extract facts using different methods</li> <li>LLM Integration - Set up AI-powered extraction</li> <li>Temporal Queries - Query facts across time</li> </ul>"},{"location":"guides/#entity-management","title":"Entity Management","text":"<ul> <li>Entity Management - Create, resolve, and merge entities</li> </ul>"},{"location":"guides/#performance","title":"Performance","text":"<ul> <li>Batch Processing - Process content in parallel</li> </ul>"},{"location":"guides/batch-processing/","title":"Batch Processing","text":"<p>FactDb uses the <code>simple_flow</code> gem to provide concurrent pipeline processing for efficient batch operations.</p>"},{"location":"guides/batch-processing/#overview","title":"Overview","text":"<p>Batch processing is useful for:</p> <ul> <li>Processing multiple documents at once</li> <li>Resolving many entity names</li> <li>Detecting conflicts across entities</li> <li>Bulk fact extraction</li> </ul>"},{"location":"guides/batch-processing/#batch-extraction","title":"Batch Extraction","text":""},{"location":"guides/batch-processing/#sequential-processing","title":"Sequential Processing","text":"<p>Process content one at a time:</p> <pre><code>facts = FactDb.new\n\nsource_ids = [content1.id, content2.id, content3.id]\n\nresults = facts.batch_extract(\n  source_ids,\n  extractor: :llm,\n  parallel: false\n)\n</code></pre>"},{"location":"guides/batch-processing/#parallel-processing","title":"Parallel Processing","text":"<p>Process content concurrently (default):</p> <pre><code>results = facts.batch_extract(\n  source_ids,\n  extractor: :llm,\n  parallel: true  # default\n)\n\nresults.each do |result|\n  puts \"Content #{result[:source_id]}:\"\n  puts \"  Facts extracted: #{result[:facts].count}\"\n  puts \"  Error: #{result[:error]}\" if result[:error]\nend\n</code></pre>"},{"location":"guides/batch-processing/#result-structure","title":"Result Structure","text":"<pre><code>result = {\n  source_id: 123,\n  facts: [&lt;Fact&gt;, &lt;Fact&gt;, ...],  # Extracted facts\n  error: nil                      # Error message if failed\n}\n</code></pre>"},{"location":"guides/batch-processing/#batch-entity-resolution","title":"Batch Entity Resolution","text":"<p>Resolve multiple names at once:</p> <pre><code>names = [\n  \"Paula Chen\",\n  \"John Smith\",\n  \"Microsoft\",\n  \"Acme Corporation\",\n  \"Seattle\"\n]\n\nresults = facts.batch_resolve_entities(names, type: nil)\n\nresults.each do |result|\n  case result[:status]\n  when :resolved\n    puts \"#{result[:name]} -&gt; #{result[:entity].name}\"\n  when :not_found\n    puts \"#{result[:name]} -&gt; Not found\"\n  when :error\n    puts \"#{result[:name]} -&gt; Error: #{result[:error]}\"\n  end\nend\n</code></pre>"},{"location":"guides/batch-processing/#with-type-filtering","title":"With Type Filtering","text":"<pre><code># Only resolve as person entities\nresults = facts.batch_resolve_entities(names, type: :person)\n</code></pre>"},{"location":"guides/batch-processing/#conflict-detection","title":"Conflict Detection","text":"<p>Check multiple entities for conflicting facts:</p> <pre><code>entity_ids = [paula.id, john.id, microsoft.id]\n\nresults = facts.detect_fact_conflicts(entity_ids)\n\nresults.each do |result|\n  if result[:conflict_count] &gt; 0\n    puts \"Entity #{result[:entity_id]} has #{result[:conflict_count]} conflicts:\"\n    result[:conflicts].each do |conflict|\n      puts \"  #{conflict[:fact1].text}\"\n      puts \"  vs\"\n      puts \"  #{conflict[:fact2].text}\"\n      puts \"  Similarity: #{conflict[:similarity]}\"\n    end\n  end\nend\n</code></pre>"},{"location":"guides/batch-processing/#using-pipelines-directly","title":"Using Pipelines Directly","text":"<p>For more control, use the pipeline classes directly:</p>"},{"location":"guides/batch-processing/#extraction-pipeline","title":"Extraction Pipeline","text":"<pre><code>pipeline = FactDb::Pipeline::ExtractionPipeline.new(FactDb.config)\n\n# Sequential\nresults = pipeline.process(contents, extractor: :llm)\n\n# Parallel\nresults = pipeline.process_parallel(contents, extractor: :llm)\n</code></pre>"},{"location":"guides/batch-processing/#resolution-pipeline","title":"Resolution Pipeline","text":"<pre><code>pipeline = FactDb::Pipeline::ResolutionPipeline.new(FactDb.config)\n\n# Resolve entities\nresults = pipeline.resolve_entities(names, type: :person)\n\n# Detect conflicts\nresults = pipeline.detect_conflicts(entity_ids)\n</code></pre>"},{"location":"guides/batch-processing/#simpleflow-integration","title":"SimpleFlow Integration","text":"<p>FactDb's pipelines are built on SimpleFlow:</p> <pre><code>require 'simple_flow'\n\n# Create custom pipeline\npipeline = SimpleFlow::Pipeline.new do\n  # Step 1: Validate\n  step -&gt;(result) {\n    content = result.value\n    if source.content.blank?\n      result.halt(\"Empty content\")\n    else\n      result.continue(content)\n    end\n  }\n\n  # Step 2: Extract\n  step -&gt;(result) {\n    facts = extractor.extract(result.value)\n    result.continue(facts)\n  }\n\n  # Step 3: Validate facts\n  step -&gt;(result) {\n    valid_facts = result.value.select(&amp;:valid?)\n    result.continue(valid_facts)\n  }\nend\n\n# Execute\nresult = pipeline.call(SimpleFlow::Result.new(content))\n</code></pre>"},{"location":"guides/batch-processing/#error-handling","title":"Error Handling","text":""},{"location":"guides/batch-processing/#graceful-degradation","title":"Graceful Degradation","text":"<pre><code>results = facts.batch_extract(source_ids, extractor: :llm)\n\nsuccessful = results.select { |r| r[:error].nil? }\nfailed = results.reject { |r| r[:error].nil? }\n\nputs \"Successful: #{successful.count}\"\nputs \"Failed: #{failed.count}\"\n\n# Retry failed items with different extractor\nif failed.any?\n  retry_ids = failed.map { |r| r[:source_id] }\n  retry_results = facts.batch_extract(retry_ids, extractor: :rule_based)\nend\n</code></pre>"},{"location":"guides/batch-processing/#logging-errors","title":"Logging Errors","text":"<pre><code>results.each do |result|\n  if result[:error]\n    logger.error(\n      \"Extraction failed\",\n      source_id: result[:source_id],\n      error: result[:error]\n    )\n  end\nend\n</code></pre>"},{"location":"guides/batch-processing/#performance-considerations","title":"Performance Considerations","text":""},{"location":"guides/batch-processing/#optimal-batch-size","title":"Optimal Batch Size","text":"<pre><code># Process in batches of 10-50 for optimal performance\nsource_ids.each_slice(25) do |batch|\n  results = facts.batch_extract(batch, parallel: true)\n  process_results(results)\nend\n</code></pre>"},{"location":"guides/batch-processing/#rate-limiting","title":"Rate Limiting","text":"<p>For LLM extraction, add delays between batches:</p> <pre><code>source_ids.each_slice(10) do |batch|\n  results = facts.batch_extract(batch, extractor: :llm)\n  process_results(results)\n  sleep(2)  # Rate limit\nend\n</code></pre>"},{"location":"guides/batch-processing/#memory-management","title":"Memory Management","text":"<pre><code># Process results immediately to avoid memory buildup\nsource_ids.each_slice(50) do |batch|\n  results = facts.batch_extract(batch)\n\n  results.each do |result|\n    # Process and discard\n    save_facts(result[:facts])\n  end\n\n  # Force garbage collection if needed\n  GC.start if batch_count % 10 == 0\nend\n</code></pre>"},{"location":"guides/batch-processing/#monitoring","title":"Monitoring","text":"<p>Track batch processing metrics:</p> <pre><code>start_time = Time.now\n\nresults = facts.batch_extract(source_ids, parallel: true)\n\nduration = Time.now - start_time\nsuccess_rate = results.count { |r| r[:error].nil? }.to_f / results.count\n\nputs \"Processed #{results.count} items in #{duration}s\"\nputs \"Success rate: #{(success_rate * 100).round(1)}%\"\nputs \"Items/second: #{(results.count / duration).round(2)}\"\n</code></pre>"},{"location":"guides/batch-processing/#best-practices","title":"Best Practices","text":""},{"location":"guides/batch-processing/#1-use-parallel-for-large-batches","title":"1. Use Parallel for Large Batches","text":"<pre><code># Sequential for small batches (&lt; 5 items)\nif source_ids.count &lt; 5\n  results = facts.batch_extract(source_ids, parallel: false)\nelse\n  results = facts.batch_extract(source_ids, parallel: true)\nend\n</code></pre>"},{"location":"guides/batch-processing/#2-handle-partial-failures","title":"2. Handle Partial Failures","text":"<pre><code>def process_batch(source_ids)\n  results = facts.batch_extract(source_ids)\n\n  {\n    successful: results.select { |r| r[:error].nil? },\n    failed: results.reject { |r| r[:error].nil? }\n  }\nend\n\nbatch_result = process_batch(source_ids)\nretry_failed(batch_result[:failed]) if batch_result[:failed].any?\n</code></pre>"},{"location":"guides/batch-processing/#3-log-progress","title":"3. Log Progress","text":"<pre><code>total = source_ids.count\nprocessed = 0\n\nsource_ids.each_slice(25) do |batch|\n  results = facts.batch_extract(batch)\n  processed += batch.count\n\n  logger.info \"Progress: #{processed}/#{total} (#{(processed.to_f/total*100).round(1)}%)\"\nend\n</code></pre>"},{"location":"guides/batch-processing/#4-use-appropriate-extractors","title":"4. Use Appropriate Extractors","text":"<pre><code># LLM for complex documents\ncomplex_docs = sources.select { |s| s.content.length &gt; 1000 }\nfacts.batch_extract(complex_docs.map(&amp;:id), extractor: :llm)\n\n# Rule-based for simple, structured content\nsimple_docs = sources.select { |s| s.content.length &lt;= 1000 }\nfacts.batch_extract(simple_docs.map(&amp;:id), extractor: :rule_based)\n</code></pre>"},{"location":"guides/configuration/","title":"Configuration","text":"<p>FactDb uses the <code>anyway_config</code> gem for flexible configuration via environment variables, YAML files, or Ruby code. Configuration uses nested sections for better organization.</p>"},{"location":"guides/configuration/#configuration-sources","title":"Configuration Sources","text":"<p>Configuration is loaded from multiple sources (lowest to highest priority):</p> <ol> <li>Bundled defaults - <code>lib/fact_db/config/defaults.yml</code> (ships with gem)</li> <li>XDG user config - <code>~/.config/fact_db/fact_db.yml</code></li> <li>Project config - <code>./config/fact_db.yml</code></li> <li>Local overrides - <code>./config/fact_db.local.yml</code> (gitignored)</li> <li>Environment variables - <code>FDB_*</code></li> <li>Ruby configure block - <code>FactDb.configure { |c| ... }</code></li> </ol>"},{"location":"guides/configuration/#configuration-access-pattern","title":"Configuration Access Pattern","text":"<p>FactDb uses nested configuration sections:</p> <pre><code># Nested access\nFactDb.config.database.url\nFactDb.config.database.pool_size\nFactDb.config.llm.provider\nFactDb.config.llm.model\nFactDb.config.ranking.ts_rank_weight\n</code></pre>"},{"location":"guides/configuration/#configuration-methods","title":"Configuration Methods","text":""},{"location":"guides/configuration/#environment-variables","title":"Environment Variables","text":"<p>All settings use the <code>FDB_</code> prefix with double underscores for nested values:</p> <pre><code># Database settings\nexport FDB_DATABASE__URL=\"postgresql://localhost/fact_db\"\nexport FDB_DATABASE__POOL_SIZE=10\nexport FDB_DATABASE__TIMEOUT=30000\n\n# LLM settings\nexport FDB_LLM__PROVIDER=\"openai\"\nexport FDB_LLM__MODEL=\"gpt-4o-mini\"\nexport FDB_LLM__API_KEY=\"sk-...\"\n\n# Top-level settings\nexport FDB_FUZZY_MATCH_THRESHOLD=0.85\nexport FDB_DEFAULT_EXTRACTOR=\"llm\"\nexport FDB_LOG_LEVEL=\"debug\"\n</code></pre>"},{"location":"guides/configuration/#yaml-configuration","title":"YAML Configuration","text":"<p>Create <code>config/fact_db.yml</code> with nested sections:</p> <pre><code># Database\ndatabase:\n  url: postgresql://localhost/fact_db\n  pool_size: 10\n  timeout: 30000\n\n# Embeddings\nembedding:\n  dimensions: 1536\n\n# LLM\nllm:\n  provider: openai\n  model: gpt-4o-mini\n  api_key: &lt;%= ENV['OPENAI_API_KEY'] %&gt;\n\n# Ranking weights (should sum to 1.0)\nranking:\n  ts_rank_weight: 0.25\n  vector_similarity_weight: 0.25\n  entity_mention_weight: 0.15\n  direct_answer_weight: 0.15\n  term_overlap_weight: 0.10\n  relationship_match_weight: 0.05\n  confidence_weight: 0.05\n\n# Top-level settings\ndefault_extractor: manual\nfuzzy_match_threshold: 0.85\nauto_merge_threshold: 0.95\nlog_level: info\n</code></pre>"},{"location":"guides/configuration/#ruby-block","title":"Ruby Block","text":"<pre><code>FactDb.configure do |config|\n  # Database\n  config.database.url = \"postgresql://localhost/fact_db\"\n  config.database.pool_size = 10\n  config.database.timeout = 30_000\n\n  # Embeddings\n  config.embedding.dimensions = 1536\n  config.embedding_generator = -&gt;(text) {\n    # Your embedding generation logic\n    OpenAI::Client.new.embeddings(input: text)\n  }\n\n  # LLM (nested access)\n  config.llm.provider = :openai\n  config.llm.model = \"gpt-4o-mini\"\n  config.llm.api_key = ENV['OPENAI_API_KEY']\n\n  # Or provide a pre-configured client\n  config.llm_client = FactDb::LLM::Adapter.new(\n    provider: :anthropic,\n    model: \"claude-sonnet-4-20250514\"\n  )\n\n  # Ranking weights\n  config.ranking.ts_rank_weight = 0.30\n  config.ranking.vector_similarity_weight = 0.25\n\n  # Top-level settings\n  config.default_extractor = :llm\n  config.fuzzy_match_threshold = 0.85\n  config.auto_merge_threshold = 0.95\n\n  # Logging\n  config.logger = Rails.logger\n  config.log_level = :debug\nend\n</code></pre>"},{"location":"guides/configuration/#configuration-options","title":"Configuration Options","text":""},{"location":"guides/configuration/#database-settings","title":"Database Settings","text":"<p>Access: <code>FactDb.config.database.*</code></p> Option Type Default Description <code>url</code> String nil PostgreSQL connection URL <code>host</code> String localhost Database host <code>port</code> Integer 5432 Database port <code>name</code> String nil Database name <code>user</code> String nil Database user <code>password</code> String nil Database password <code>pool_size</code> Integer 5 Connection pool size <code>timeout</code> Integer 30000 Query timeout in milliseconds"},{"location":"guides/configuration/#embedding-settings","title":"Embedding Settings","text":"<p>Access: <code>FactDb.config.embedding.*</code></p> Option Type Default Description <code>dimensions</code> Integer 1536 Vector dimensions (match your model) <code>generator</code> Proc nil Custom embedding generation function"},{"location":"guides/configuration/#llm-settings","title":"LLM Settings","text":"<p>Access: <code>FactDb.config.llm.*</code></p> Option Type Default Description <code>client</code> Object nil Pre-configured LLM client <code>provider</code> Symbol nil Provider name (:openai, :anthropic, etc.) <code>model</code> String varies Model name <code>api_key</code> String nil API key"},{"location":"guides/configuration/#ranking-settings","title":"Ranking Settings","text":"<p>Access: <code>FactDb.config.ranking.*</code></p> Option Type Default Description <code>ts_rank_weight</code> Float 0.25 PostgreSQL full-text search weight <code>vector_similarity_weight</code> Float 0.25 Semantic similarity weight <code>entity_mention_weight</code> Float 0.15 Entity mentions weight <code>direct_answer_weight</code> Float 0.15 Direct answer pattern weight <code>term_overlap_weight</code> Float 0.10 Query word matches weight <code>relationship_match_weight</code> Float 0.05 Relationship words weight <code>confidence_weight</code> Float 0.05 Stored confidence score weight <p>Note: Weights should sum to approximately 1.0.</p>"},{"location":"guides/configuration/#top-level-settings","title":"Top-Level Settings","text":"Option Type Default Description <code>default_extractor</code> Symbol :manual Default extraction method <code>fuzzy_match_threshold</code> Float 0.85 Minimum similarity for fuzzy matching <code>auto_merge_threshold</code> Float 0.95 Similarity threshold for auto-merge <code>log_level</code> Symbol :info Log level"},{"location":"guides/configuration/#llm-provider-configuration","title":"LLM Provider Configuration","text":""},{"location":"guides/configuration/#openai","title":"OpenAI","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :openai\n  config.llm.model = \"gpt-4o-mini\"  # or \"gpt-4o\", \"gpt-4-turbo\"\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n</code></pre>"},{"location":"guides/configuration/#anthropic","title":"Anthropic","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :anthropic\n  config.llm.model = \"claude-sonnet-4-20250514\"\n  config.llm.api_key = ENV['ANTHROPIC_API_KEY']\nend\n</code></pre>"},{"location":"guides/configuration/#google-gemini","title":"Google Gemini","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :gemini\n  config.llm.model = \"gemini-2.0-flash\"\n  config.llm.api_key = ENV['GEMINI_API_KEY']\nend\n</code></pre>"},{"location":"guides/configuration/#ollama-local","title":"Ollama (Local)","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :ollama\n  config.llm.model = \"llama3.2\"\n  # No API key needed for local Ollama\nend\n</code></pre>"},{"location":"guides/configuration/#aws-bedrock","title":"AWS Bedrock","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :bedrock\n  config.llm.model = \"claude-sonnet-4\"\n  # Uses AWS credentials from environment\nend\n</code></pre>"},{"location":"guides/configuration/#openrouter","title":"OpenRouter","text":"<pre><code>FactDb.configure do |config|\n  config.llm.provider = :openrouter\n  config.llm.model = \"anthropic/claude-sonnet-4\"\n  config.llm.api_key = ENV['OPENROUTER_API_KEY']\nend\n</code></pre>"},{"location":"guides/configuration/#xdg-user-configuration","title":"XDG User Configuration","text":"<p>FactDb supports XDG Base Directory Specification for user-level configuration:</p> <ul> <li><code>~/.config/fact_db/fact_db.yml</code> (Linux/macOS)</li> <li><code>~/Library/Application Support/fact_db/fact_db.yml</code> (macOS)</li> <li><code>$XDG_CONFIG_HOME/fact_db/fact_db.yml</code> (if XDG_CONFIG_HOME is set)</li> </ul> <p>This allows you to set personal defaults that apply across all projects.</p>"},{"location":"guides/configuration/#environment-specific-configuration","title":"Environment-Specific Configuration","text":"<p>The bundled defaults support environment-specific overrides:</p> <pre><code># config/fact_db.yml\ndefaults:\n  embedding:\n    dimensions: 1536\n  fuzzy_match_threshold: 0.85\n\ndevelopment:\n  database:\n    name: fact_db_development\n  log_level: debug\n\ntest:\n  database:\n    name: fact_db_test\n  log_level: warn\n\nproduction:\n  database:\n    pool_size: 25\n  log_level: info\n</code></pre> <p>Environment is detected from: <code>FDB_ENV</code> &gt; <code>RAILS_ENV</code> &gt; <code>RACK_ENV</code> &gt; <code>'development'</code></p>"},{"location":"guides/configuration/#validation","title":"Validation","text":"<p>Validate configuration at startup:</p> <pre><code>FactDb.configure do |config|\n  config.database.url = ENV['DATABASE_URL']\nend\n\n# Raises ConfigurationError if invalid\nFactDb.config.validate!\n</code></pre>"},{"location":"guides/configuration/#reset-configuration","title":"Reset Configuration","text":"<p>For testing, reset configuration between tests:</p> <pre><code># In test setup\nFactDb.reset_configuration!\n</code></pre>"},{"location":"guides/configuration/#environment-helpers","title":"Environment Helpers","text":"<pre><code>FactDb.config.test?        # true if FDB_ENV == 'test'\nFactDb.config.development? # true if FDB_ENV == 'development'\nFactDb.config.production?  # true if FDB_ENV == 'production'\nFactDb.config.environment  # returns current environment string\n</code></pre>"},{"location":"guides/entity-management/","title":"Entity Management","text":"<p>Entities represent real-world things mentioned in facts - people, organizations, places, and more.</p>"},{"location":"guides/entity-management/#creating-entities","title":"Creating Entities","text":""},{"location":"guides/entity-management/#basic-creation","title":"Basic Creation","text":"<pre><code>facts = FactDb.new\n\nperson = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person\n)\n</code></pre>"},{"location":"guides/entity-management/#with-aliases","title":"With Aliases","text":"<pre><code>person = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\", \"P. Chen\", \"Chen, Paula\"]\n)\n</code></pre>"},{"location":"guides/entity-management/#with-metadata","title":"With Metadata","text":"<pre><code>person = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  aliases: [\"Paula\"],\n  metadata: {\n    employee_id: \"E12345\",\n    department: \"Engineering\",\n    start_date: \"2024-01-10\"\n  }\n)\n</code></pre>"},{"location":"guides/entity-management/#entity-types","title":"Entity Types","text":"Type Description Examples <code>:person</code> Individual people Paula Chen, John Smith <code>:organization</code> Companies, teams Microsoft, Platform Team <code>:place</code> Locations San Francisco, Building A <code>:product</code> Products, services Windows 11, Azure <code>:event</code> Named events Q4 Earnings, Annual Review <pre><code># Custom types are also supported\nentity = facts.entity_service.create(\n  \"TPS Report\",\n  type: :document_type\n)\n</code></pre>"},{"location":"guides/entity-management/#managing-aliases","title":"Managing Aliases","text":""},{"location":"guides/entity-management/#add-alias","title":"Add Alias","text":"<pre><code>facts.entity_service.add_alias(\n  entity.id,\n  \"P. Chen\",\n  type: :abbreviation,\n  confidence: 0.95\n)\n</code></pre>"},{"location":"guides/entity-management/#alias-types","title":"Alias Types","text":"Type Description <code>nickname</code> Informal names <code>abbreviation</code> Shortened forms <code>formal</code> Formal/legal names <code>maiden_name</code> Previous names <code>trading_name</code> Business aliases"},{"location":"guides/entity-management/#list-aliases","title":"List Aliases","text":"<pre><code>entity.entity_aliases.each do |alias_record|\n  puts \"#{alias_record.name} (#{alias_record.type})\"\n  puts \"  Confidence: #{alias_record.confidence}\"\nend\n</code></pre>"},{"location":"guides/entity-management/#remove-alias","title":"Remove Alias","text":"<pre><code>facts.entity_service.remove_alias(entity.id, \"Old Name\")\n</code></pre>"},{"location":"guides/entity-management/#entity-resolution","title":"Entity Resolution","text":""},{"location":"guides/entity-management/#basic-resolution","title":"Basic Resolution","text":"<pre><code># Resolve a name to an entity\nentity = facts.resolve_entity(\"Paula Chen\")\n\n# Returns existing entity or nil if not found\n</code></pre>"},{"location":"guides/entity-management/#type-constrained-resolution","title":"Type-Constrained Resolution","text":"<pre><code># Only match person entities\nperson = facts.resolve_entity(\"Paula\", type: :person)\n\n# Only match organizations\norg = facts.resolve_entity(\"Microsoft\", type: :organization)\n</code></pre>"},{"location":"guides/entity-management/#resolution-strategies","title":"Resolution Strategies","text":"<p>The resolver tries in order:</p> <ol> <li>Exact match on canonical name</li> <li>Alias match on registered aliases</li> <li>Fuzzy match using Levenshtein distance</li> </ol> <pre><code># Configure fuzzy matching\nFactDb.configure do |config|\n  config.fuzzy_match_threshold = 0.85  # 85% similarity required\nend\n</code></pre>"},{"location":"guides/entity-management/#batch-resolution","title":"Batch Resolution","text":"<pre><code>names = [\"Paula Chen\", \"John Smith\", \"Microsoft\", \"Seattle\"]\n\nresults = facts.batch_resolve_entities(names)\n\nresults.each do |result|\n  status = result[:status]  # :resolved, :not_found, :error\n  entity = result[:entity]\n  puts \"#{result[:name]}: #{status} -&gt; #{entity&amp;.name}\"\nend\n</code></pre>"},{"location":"guides/entity-management/#merging-entities","title":"Merging Entities","text":"<p>When duplicate entities are discovered:</p> <pre><code># Merge entity2 into entity1 (entity1 is kept)\nfacts.entity_service.merge(entity1.id, entity2.id)\n\n# After merge:\nentity2.reload\nentity2.resolution_status  # =&gt; \"merged\"\nentity2.canonical_id     # =&gt; entity1.id\n</code></pre>"},{"location":"guides/entity-management/#what-happens-on-merge","title":"What Happens on Merge","text":"<ol> <li>Entity2's status changes to \"merged\"</li> <li>Entity2 points to entity1 via <code>canonical_id</code></li> <li>Entity2's aliases are copied to entity1</li> <li>All facts mentioning entity2 now also reference entity1</li> </ol>"},{"location":"guides/entity-management/#auto-merge","title":"Auto-Merge","text":"<p>Configure automatic merging for high-confidence matches:</p> <pre><code>FactDb.configure do |config|\n  config.auto_merge_threshold = 0.95  # Auto-merge at 95% similarity\nend\n</code></pre>"},{"location":"guides/entity-management/#updating-entities","title":"Updating Entities","text":""},{"location":"guides/entity-management/#update-canonical-name","title":"Update Canonical Name","text":"<pre><code>facts.entity_service.update(\n  entity.id,\n  name: \"Paula M. Chen\"\n)\n</code></pre>"},{"location":"guides/entity-management/#update-metadata","title":"Update Metadata","text":"<pre><code>facts.entity_service.update(\n  entity.id,\n  metadata: entity.metadata.merge(title: \"Senior Principal Engineer\")\n)\n</code></pre>"},{"location":"guides/entity-management/#change-type","title":"Change Type","text":"<pre><code># Reclassify entity type\nfacts.entity_service.update(\n  entity.id,\n  type: :organization\n)\n</code></pre>"},{"location":"guides/entity-management/#resolution-status","title":"Resolution Status","text":"Status Description <code>unresolved</code> Entity created but not confirmed <code>resolved</code> Entity identity confirmed <code>merged</code> Entity merged into another"},{"location":"guides/entity-management/#mark-as-resolved","title":"Mark as Resolved","text":"<pre><code>facts.entity_service.update(\n  entity.id,\n  resolution_status: :resolved\n)\n</code></pre>"},{"location":"guides/entity-management/#find-unresolved","title":"Find Unresolved","text":"<pre><code>unresolved = FactDb::Models::Entity\n  .where(resolution_status: 'unresolved')\n  .order(created_at: :desc)\n</code></pre>"},{"location":"guides/entity-management/#querying-entities","title":"Querying Entities","text":""},{"location":"guides/entity-management/#find-by-id","title":"Find by ID","text":"<pre><code>entity = facts.entity_service.find(entity_id)\n</code></pre>"},{"location":"guides/entity-management/#search-by-name","title":"Search by Name","text":"<pre><code>entities = facts.entity_service.search(\"Paula\")\n</code></pre>"},{"location":"guides/entity-management/#filter-by-type","title":"Filter by Type","text":"<pre><code>people = FactDb::Models::Entity\n  .where(type: 'person')\n  .where.not(resolution_status: 'merged')\n</code></pre>"},{"location":"guides/entity-management/#find-entities-in-source","title":"Find Entities in Source","text":"<pre><code># Find all entities mentioned in a source\nentities = facts.entity_service.in_source(source.id)\n</code></pre>"},{"location":"guides/entity-management/#find-related-entities","title":"Find Related Entities","text":"<pre><code># Entities mentioned in facts about Paula\nrelated = facts.entity_service.related_to(paula.id)\n</code></pre>"},{"location":"guides/entity-management/#semantic-search","title":"Semantic Search","text":"<p>Search entities by meaning:</p> <pre><code># Find entities similar to a description\nsimilar = facts.entity_service.semantic_search(\n  \"software engineering leadership\",\n  type: :person,\n  limit: 10\n)\n</code></pre>"},{"location":"guides/entity-management/#best-practices","title":"Best Practices","text":""},{"location":"guides/entity-management/#1-use-comprehensive-aliases","title":"1. Use Comprehensive Aliases","text":"<pre><code>entity = facts.entity_service.create(\n  \"International Business Machines Corporation\",\n  type: :organization,\n  aliases: [\n    \"IBM\",\n    \"Big Blue\",\n    \"International Business Machines\",\n    \"IBM Corp\",\n    \"IBM Corporation\"\n  ]\n)\n</code></pre>"},{"location":"guides/entity-management/#2-store-relevant-metadata","title":"2. Store Relevant Metadata","text":"<pre><code>person = facts.entity_service.create(\n  \"Paula Chen\",\n  type: :person,\n  metadata: {\n    # Stable identifiers\n    employee_id: \"E12345\",\n    linkedin_url: \"linkedin.com/in/paulachen\",\n\n    # Useful context\n    department: \"Engineering\",\n    location: \"San Francisco\"\n  }\n)\n</code></pre>"},{"location":"guides/entity-management/#3-review-unresolved-entities","title":"3. Review Unresolved Entities","text":"<pre><code># Periodically review unresolved entities\nunresolved = FactDb::Models::Entity\n  .where(resolution_status: 'unresolved')\n  .where('created_at &lt; ?', 1.week.ago)\n\nunresolved.each do |entity|\n  # Try to find duplicates\n  similar = facts.entity_service.search(entity.name)\n  if similar.count &gt; 1\n    puts \"Potential duplicate: #{entity.name}\"\n  end\nend\n</code></pre>"},{"location":"guides/entity-management/#4-handle-merged-entities","title":"4. Handle Merged Entities","text":"<pre><code># When querying, exclude merged entities\nactive_entities = FactDb::Models::Entity\n  .where.not(resolution_status: 'merged')\n\n# Or follow the merge chain\ndef canonical_entity(entity)\n  while entity.canonical_id\n    entity = FactDb::Models::Entity.find(entity.canonical_id)\n  end\n  entity\nend\n</code></pre>"},{"location":"guides/entity-management/#5-validate-entity-types","title":"5. Validate Entity Types","text":"<pre><code>VALID_TYPES = %i[person organization place product event].freeze\n\ndef create_entity(name, type:)\n  unless VALID_TYPES.include?(type.to_sym)\n    raise ArgumentError, \"Invalid entity type: #{type}\"\n  end\n  facts.entity_service.create(name, type: type)\nend\n</code></pre>"},{"location":"guides/extracting-facts/","title":"Extracting Facts","text":"<p>Facts are extracted from content using one of three methods: manual, LLM-powered, or rule-based.</p>"},{"location":"guides/extracting-facts/#extraction-methods","title":"Extraction Methods","text":""},{"location":"guides/extracting-facts/#manual-extraction","title":"Manual Extraction","text":"<p>Create facts directly via the API:</p> <pre><code>facts = FactDb.new\n\n# Create entities first\npaula = facts.entity_service.create(\"Paula Chen\", type: :person)\nmicrosoft = facts.entity_service.create(\"Microsoft\", type: :organization)\n\n# Create fact with explicit links\nfact = facts.fact_service.create(\n  \"Paula Chen joined Microsoft as Principal Engineer\",\n  valid_at: Date.parse(\"2024-01-10\"),\n  mentions: [\n    { entity: paula, role: \"subject\", text: \"Paula Chen\" },\n    { entity: microsoft, role: \"organization\", text: \"Microsoft\" }\n  ],\n  sources: [\n    { source: source, type: \"primary\", excerpt: \"...accepted the offer...\" }\n  ]\n)\n</code></pre>"},{"location":"guides/extracting-facts/#llm-extraction","title":"LLM Extraction","text":"<p>Use AI to automatically extract facts:</p> <pre><code># Configure LLM\nFactDb.configure do |config|\n  config.llm.provider = :openai\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n\nfacts = FactDb.new\n\n# Extract facts from source\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  puts fact.text\n  puts \"  Valid from: #{fact.valid_at}\"\n  puts \"  Entities: #{fact.entity_mentions.map(&amp;:entity).map(&amp;:name)}\"\nend\n</code></pre>"},{"location":"guides/extracting-facts/#rule-based-extraction","title":"Rule-Based Extraction","text":"<p>Use regex patterns for structured content:</p> <pre><code>extracted = facts.extract_facts(source.id, extractor: :rule_based)\n</code></pre> <p>The rule-based extractor includes patterns for:</p> <ul> <li>Dates and time references</li> <li>Employment events (joined, promoted, left)</li> <li>Title/role changes</li> <li>Location references</li> <li>Organizational relationships</li> </ul>"},{"location":"guides/extracting-facts/#setting-default-extractor","title":"Setting Default Extractor","text":"<pre><code>FactDb.configure do |config|\n  config.default_extractor = :llm  # or :manual, :rule_based\nend\n\n# Uses configured default\nextracted = facts.extract_facts(source.id)\n</code></pre>"},{"location":"guides/extracting-facts/#fact-structure","title":"Fact Structure","text":"<p>Every extracted fact includes:</p> <pre><code>fact = Models::Fact.new(\n  text: \"Paula Chen is Principal Engineer at Microsoft\",\n  digest: \"sha256...\",           # For deduplication\n  valid_at: Time.parse(\"2024-01-10\"),\n  invalid_at: nil,                   # nil = currently valid\n  status: \"canonical\",               # canonical, superseded, corroborated, synthesized\n  confidence: 0.95,                  # Extraction confidence\n  extraction_method: \"llm\",          # manual, llm, rule_based\n  metadata: {}                       # Additional data\n)\n</code></pre>"},{"location":"guides/extracting-facts/#entity-mentions","title":"Entity Mentions","text":"<p>Facts link to entities via mentions:</p> <pre><code>fact.add_mention(\n  entity: paula,\n  text: \"Paula Chen\",    # How entity was mentioned\n  role: \"subject\",       # Role in the fact\n  confidence: 0.95       # Resolution confidence\n)\n</code></pre>"},{"location":"guides/extracting-facts/#mention-roles","title":"Mention Roles","text":"Role Description Example <code>subject</code> Primary actor \"Paula joined...\" <code>object</code> Target \"...hired Paula\" <code>organization</code> Company/team \"...at Microsoft\" <code>location</code> Place \"...in Seattle\" <code>role</code> Title/position \"...as Engineer\" <code>temporal</code> Time reference \"...in Q4 2024\" <code>attribute</code> Property \"...with 10 years experience\""},{"location":"guides/extracting-facts/#source-links","title":"Source Links","text":"<p>Facts link to source content:</p> <pre><code>fact.add_source(\n  source: email_source,\n  type: \"primary\",\n  excerpt: \"Paula has accepted our offer to join as Principal Engineer...\",\n  confidence: 0.95\n)\n</code></pre>"},{"location":"guides/extracting-facts/#source-types","title":"Source Types","text":"Type Description <code>primary</code> Direct source of the fact <code>supporting</code> Confirms the fact <code>contradicting</code> Contradicts the fact"},{"location":"guides/extracting-facts/#batch-extraction","title":"Batch Extraction","text":"<p>Process multiple content items:</p> <pre><code>source_ids = [source1.id, source2.id, source3.id]\n\n# Sequential processing\nresults = facts.batch_extract(source_ids, parallel: false)\n\n# Parallel processing (default)\nresults = facts.batch_extract(source_ids, parallel: true)\n\nresults.each do |result|\n  puts \"Source #{result[:source_id]}:\"\n  puts \"  Facts: #{result[:facts].count}\"\n  puts \"  Error: #{result[:error]}\" if result[:error]\nend\n</code></pre>"},{"location":"guides/extracting-facts/#custom-extractors","title":"Custom Extractors","text":"<p>Create custom extractors by extending the base class:</p> <pre><code>class MyExtractor &lt; FactDb::Extractors::Base\n  def extract(source)\n    extracted = []\n\n    # Your extraction logic here\n    # Parse source.content\n    # Create fact records\n\n    extracted\n  end\nend\n\n# Register and use\nfacts.fact_service.extract_from_source(\n  source.id,\n  extractor: MyExtractor.new(config)\n)\n</code></pre>"},{"location":"guides/extracting-facts/#extraction-confidence","title":"Extraction Confidence","text":"<p>Track confidence levels:</p> <pre><code># High confidence - direct statement\nfact = facts.fact_service.create(\n  \"Paula is Principal Engineer\",\n  confidence: 0.95\n)\n\n# Medium confidence - inferred\nfact = facts.fact_service.create(\n  \"Paula likely works in Engineering\",\n  confidence: 0.7\n)\n\n# Low confidence - speculation\nfact = facts.fact_service.create(\n  \"Paula may be promoted soon\",\n  confidence: 0.4\n)\n</code></pre>"},{"location":"guides/extracting-facts/#post-extraction-processing","title":"Post-Extraction Processing","text":"<p>After extraction, you may want to:</p>"},{"location":"guides/extracting-facts/#resolve-entities","title":"Resolve Entities","text":"<pre><code>extracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  fact.entity_mentions.each do |mention|\n    if mention.entity.nil?\n      # Resolve unlinked mention\n      entity = facts.resolve_entity(mention.mention_text)\n      mention.update!(entity: entity) if entity\n    end\n  end\nend\n</code></pre>"},{"location":"guides/extracting-facts/#detect-conflicts","title":"Detect Conflicts","text":"<pre><code>conflicts = facts.fact_service.resolver.find_conflicts(\n  entity_id: paula.id\n)\n\nconflicts.each do |conflict|\n  puts \"Conflict between:\"\n  puts \"  #{conflict[:fact1].text}\"\n  puts \"  #{conflict[:fact2].text}\"\nend\n</code></pre>"},{"location":"guides/extracting-facts/#corroborate-facts","title":"Corroborate Facts","text":"<pre><code># If multiple sources say the same thing\nif fact1.text.similar_to?(fact2.text)\n  facts.fact_service.resolver.corroborate(fact1.id, fact2.id)\nend\n</code></pre>"},{"location":"guides/extracting-facts/#best-practices","title":"Best Practices","text":""},{"location":"guides/extracting-facts/#1-review-llm-extractions","title":"1. Review LLM Extractions","text":"<pre><code>extracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.select { |f| f.confidence &lt; 0.8 }.each do |fact|\n  # Flag for human review\n  fact.update!(metadata: fact.metadata.merge(needs_review: true))\nend\n</code></pre>"},{"location":"guides/extracting-facts/#2-validate-temporal-information","title":"2. Validate Temporal Information","text":"<pre><code># Ensure valid_at is reasonable\nif fact.valid_at &gt; Time.current\n  logger.warn \"Future date detected: #{fact.valid_at}\"\nend\n</code></pre>"},{"location":"guides/extracting-facts/#3-link-sources","title":"3. Link Sources","text":"<pre><code># Always link facts to their sources\nfact = facts.fact_service.create(\n  \"Important fact\",\n  valid_at: Date.today,\n  sources: [{ source: source_record, type: \"primary\" }]\n)\n</code></pre>"},{"location":"guides/extracting-facts/#4-handle-extraction-errors","title":"4. Handle Extraction Errors","text":"<pre><code>begin\n  extracted = facts.extract_facts(source.id, extractor: :llm)\nrescue FactDb::ExtractionError =&gt; e\n  logger.error \"Extraction failed: #{e.message}\"\n  # Fall back to manual or rule-based\n  extracted = facts.extract_facts(source.id, extractor: :rule_based)\nend\n</code></pre>"},{"location":"guides/ingesting-content/","title":"Ingesting Content","text":"<p>Content is the foundation of FactDb - immutable source documents from which facts are extracted.</p>"},{"location":"guides/ingesting-content/#basic-ingestion","title":"Basic Ingestion","text":"<pre><code>facts = FactDb.new\n\ncontent = facts.ingest(\n  \"Paula Chen joined Microsoft as Principal Engineer on January 10, 2024.\",\n  type: :announcement\n)\n</code></pre>"},{"location":"guides/ingesting-content/#full-options","title":"Full Options","text":"<pre><code>source = facts.ingest(\n  text_content,\n  type: :email,\n  title: \"RE: Offer Letter - Paula Chen\",\n  source_uri: \"mailto:hr@company.com/msg/12345\",\n  captured_at: Time.parse(\"2024-01-08 10:30:00\"),\n  metadata: {\n    from: \"hr@company.com\",\n    to: \"hiring@company.com\",\n    cc: [\"manager@company.com\"],\n    subject: \"RE: Offer Letter - Paula Chen\",\n    thread_id: \"THR-12345\"\n  }\n)\n</code></pre>"},{"location":"guides/ingesting-content/#content-types","title":"Content Types","text":"<p>Choose a type that best describes the source:</p> Type Use Case <code>:email</code> Email messages <code>:document</code> General documents, PDFs <code>:article</code> News articles, blog posts <code>:transcript</code> Meeting transcripts, interviews <code>:report</code> Reports, analysis documents <code>:announcement</code> Official announcements <code>:social</code> Social media posts <code>:form</code> Structured forms, surveys <code>:note</code> Notes, memos <pre><code># Custom types are also allowed\ncontent = facts.ingest(text, type: :slack_message)\n</code></pre>"},{"location":"guides/ingesting-content/#metadata","title":"Metadata","text":"<p>Store additional context in metadata:</p> <pre><code># Email metadata\nmetadata: {\n  from: \"sender@example.com\",\n  to: \"recipient@example.com\",\n  subject: \"Important Update\",\n  message_id: \"&lt;abc123@mail.example.com&gt;\"\n}\n\n# Document metadata\nmetadata: {\n  author: \"Jane Smith\",\n  version: \"2.1\",\n  department: \"Engineering\",\n  classification: \"internal\"\n}\n\n# Article metadata\nmetadata: {\n  author: \"John Doe\",\n  publication: \"Tech News\",\n  url: \"https://technews.com/article/123\",\n  published_at: \"2024-01-15T14:30:00Z\"\n}\n</code></pre>"},{"location":"guides/ingesting-content/#deduplication","title":"Deduplication","text":"<p>Content is automatically deduplicated by SHA256 hash:</p> <pre><code># First ingestion - creates new record\nsource1 = facts.ingest(\"Hello world\", type: :note)\n\n# Second ingestion - returns existing record\nsource2 = facts.ingest(\"Hello world\", type: :note)\n\nsource1.id == source2.id  # =&gt; true\n</code></pre>"},{"location":"guides/ingesting-content/#timestamps","title":"Timestamps","text":""},{"location":"guides/ingesting-content/#captured_at","title":"captured_at","text":"<p>When the content was captured/received (defaults to current time):</p> <pre><code># Email received yesterday\ncontent = facts.ingest(\n  email_body,\n  type: :email,\n  captured_at: Time.parse(\"2024-01-14 09:00:00\")\n)\n</code></pre>"},{"location":"guides/ingesting-content/#created_at","title":"created_at","text":"<p>Automatically set when record is created (system timestamp).</p>"},{"location":"guides/ingesting-content/#batch-ingestion","title":"Batch Ingestion","text":"<p>For multiple documents:</p> <pre><code>documents = [\n  { text: \"Doc 1 content\", type: :document, title: \"Doc 1\" },\n  { text: \"Doc 2 content\", type: :document, title: \"Doc 2\" },\n  { text: \"Doc 3 content\", type: :document, title: \"Doc 3\" }\n]\n\ncontents = documents.map do |doc|\n  facts.ingest(doc[:text], type: doc[:type], title: doc[:title])\nend\n</code></pre>"},{"location":"guides/ingesting-content/#source-service","title":"Source Service","text":"<p>For advanced operations, use the source service directly:</p> <pre><code># Create source\nsource = facts.source_service.create(\n  text_content,\n  type: :document,\n  title: \"Annual Report\"\n)\n\n# Find by ID\nsource = facts.source_service.find(source_id)\n\n# Find by hash\nsource = facts.source_service.find_by_hash(sha256_hash)\n\n# Search by text\nresults = facts.source_service.search(\"quarterly earnings\")\n\n# Semantic search (requires embedding)\nresults = facts.source_service.semantic_search(\n  \"financial performance\",\n  limit: 10\n)\n</code></pre>"},{"location":"guides/ingesting-content/#embeddings","title":"Embeddings","text":"<p>If you configure an embedding generator, content embeddings are created automatically:</p> <pre><code>FactDb.configure do |config|\n  config.embedding_generator = -&gt;(text) {\n    # Your embedding logic\n    client.embeddings(input: text)\n  }\nend\n\n# Embeddings generated on ingest\ncontent = facts.ingest(text, type: :document)\ncontent.embedding  # =&gt; [0.123, -0.456, ...]\n</code></pre>"},{"location":"guides/ingesting-content/#source-uris","title":"Source URIs","text":"<p>Track original locations with source_uri:</p> <pre><code># Email\nsource_uri: \"mailto:sender@example.com/msg/12345\"\n\n# Web page\nsource_uri: \"https://example.com/articles/123\"\n\n# File\nsource_uri: \"file:///path/to/document.pdf\"\n\n# Database record\nsource_uri: \"db://crm/contacts/12345\"\n\n# API\nsource_uri: \"api://salesforce/leads/ABC123\"\n</code></pre>"},{"location":"guides/ingesting-content/#best-practices","title":"Best Practices","text":""},{"location":"guides/ingesting-content/#1-preserve-original-text","title":"1. Preserve Original Text","text":"<pre><code># Good - preserve original formatting\nfacts.ingest(original_email_body, type: :email)\n\n# Avoid - don't pre-process\nfacts.ingest(cleaned_text.strip.downcase, type: :email)\n</code></pre>"},{"location":"guides/ingesting-content/#2-include-context-in-metadata","title":"2. Include Context in Metadata","text":"<pre><code>content = facts.ingest(\n  transcript,\n  type: :transcript,\n  title: \"Q4 2024 Earnings Call\",\n  metadata: {\n    participants: [\"CEO\", \"CFO\", \"Analysts\"],\n    duration_minutes: 60,\n    recording_url: \"https://...\"\n  }\n)\n</code></pre>"},{"location":"guides/ingesting-content/#3-use-consistent-types","title":"3. Use Consistent Types","text":"<pre><code># Define content types for your organization\nmodule ContentTypes\n  EMAIL = :email\n  SLACK = :slack_message\n  MEETING = :meeting_transcript\n  # ...\nend\n\nfacts.ingest(text, type: ContentTypes::EMAIL)\n</code></pre>"},{"location":"guides/ingesting-content/#4-track-source","title":"4. Track Source","text":"<pre><code># Always include source information for audit trails\ncontent = facts.ingest(\n  text,\n  type: :document,\n  source_uri: \"sharepoint://documents/annual-report-2024.pdf\",\n  metadata: { uploaded_by: \"jane@company.com\" }\n)\n</code></pre>"},{"location":"guides/llm-integration/","title":"LLM Integration","text":"<p>FactDb integrates with multiple LLM providers via the <code>ruby_llm</code> gem for AI-powered fact extraction.</p>"},{"location":"guides/llm-integration/#setup","title":"Setup","text":""},{"location":"guides/llm-integration/#install-ruby_llm","title":"Install ruby_llm","text":"<p>Add to your Gemfile:</p> <pre><code>gem 'ruby_llm'\n</code></pre>"},{"location":"guides/llm-integration/#configure-provider","title":"Configure Provider","text":"OpenAIAnthropicGoogle GeminiOllama (Local)Environment Variables <pre><code>FactDb.configure do |config|\n  config.llm.provider = :openai\n  config.llm.model = \"gpt-4o-mini\"\n  config.llm.api_key = ENV['OPENAI_API_KEY']\nend\n</code></pre> <pre><code>FactDb.configure do |config|\n  config.llm.provider = :anthropic\n  config.llm.model = \"claude-sonnet-4-20250514\"\n  config.llm.api_key = ENV['ANTHROPIC_API_KEY']\nend\n</code></pre> <pre><code>FactDb.configure do |config|\n  config.llm.provider = :gemini\n  config.llm.model = \"gemini-2.0-flash\"\n  config.llm.api_key = ENV['GEMINI_API_KEY']\nend\n</code></pre> <pre><code>FactDb.configure do |config|\n  config.llm.provider = :ollama\n  config.llm.model = \"llama3.2\"\nend\n</code></pre> <pre><code>export FDB_LLM__PROVIDER=openai\nexport FDB_LLM__MODEL=gpt-4o-mini\nexport FDB_LLM__API_KEY=sk-...\n</code></pre>"},{"location":"guides/llm-integration/#supported-providers","title":"Supported Providers","text":"Provider Models Config Key OpenAI gpt-4o, gpt-4o-mini, gpt-4-turbo <code>OPENAI_API_KEY</code> Anthropic claude-sonnet-4, claude-3-haiku <code>ANTHROPIC_API_KEY</code> Google Gemini gemini-2.0-flash, gemini-pro <code>GEMINI_API_KEY</code> Ollama llama3.2, mistral, codellama (local) AWS Bedrock claude-sonnet-4, titan AWS credentials OpenRouter Various <code>OPENROUTER_API_KEY</code>"},{"location":"guides/llm-integration/#default-models","title":"Default Models","text":"<p>If no model is specified, these defaults are used:</p> <pre><code>PROVIDER_DEFAULTS = {\n  openai: \"gpt-4o-mini\",\n  anthropic: \"claude-sonnet-4-20250514\",\n  gemini: \"gemini-2.0-flash\",\n  ollama: \"llama3.2\",\n  bedrock: \"claude-sonnet-4\",\n  openrouter: \"anthropic/claude-sonnet-4\"\n}\n</code></pre>"},{"location":"guides/llm-integration/#using-llm-extraction","title":"Using LLM Extraction","text":"<pre><code>facts = FactDb.new\n\n# Ingest content\nsource = facts.ingest(\n  \"Paula Chen joined Microsoft as Principal Engineer on January 10, 2024. She previously worked at Google for 5 years.\",\n  type: :announcement\n)\n\n# Extract facts using LLM\nextracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  puts \"Fact: #{fact.text}\"\n  puts \"  Valid: #{fact.valid_at}\"\n  puts \"  Confidence: #{fact.confidence}\"\n  fact.entity_mentions.each do |m|\n    puts \"  Entity: #{m.entity.name} (#{m.mention_role})\"\n  end\nend\n</code></pre>"},{"location":"guides/llm-integration/#extraction-prompts","title":"Extraction Prompts","text":"<p>The LLM extractor uses carefully designed prompts to extract:</p> <ol> <li>Facts - Temporal assertions about entities</li> <li>Entities - People, organizations, places mentioned</li> <li>Dates - When facts became valid</li> <li>Relationships - How entities relate to facts</li> </ol>"},{"location":"guides/llm-integration/#example-prompt-structure","title":"Example Prompt Structure","text":"<pre><code>Extract temporal facts from this content. For each fact:\n1. Identify the assertion (what is being stated)\n2. Identify entities mentioned (people, organizations, places)\n3. Determine when the fact became valid\n4. Assess confidence level\n\nContent:\n{source.content}\n\nReturn JSON:\n{\n  \"facts\": [\n    {\n      \"text\": \"...\",\n      \"valid_at\": \"YYYY-MM-DD\",\n      \"entities\": [\n        {\"name\": \"...\", \"type\": \"person|organization|place\", \"role\": \"subject|object|...\"}\n      ],\n      \"confidence\": 0.0-1.0\n    }\n  ]\n}\n</code></pre>"},{"location":"guides/llm-integration/#custom-llm-client","title":"Custom LLM Client","text":"<p>Provide a pre-configured client:</p> <pre><code># Create custom adapter\nadapter = FactDb::LLM::Adapter.new(\n  provider: :openai,\n  model: \"gpt-4o\",\n  api_key: ENV['OPENAI_API_KEY']\n)\n\nFactDb.configure do |config|\n  config.llm_client = adapter\nend\n</code></pre>"},{"location":"guides/llm-integration/#direct-llm-usage","title":"Direct LLM Usage","text":"<p>Use the adapter directly:</p> <pre><code>adapter = FactDb::LLM::Adapter.new(\n  provider: :anthropic,\n  model: \"claude-sonnet-4-20250514\"\n)\n\nresponse = adapter.chat(\"Extract facts from: Paula joined Microsoft on Jan 10, 2024\")\nputs response\n</code></pre>"},{"location":"guides/llm-integration/#error-handling","title":"Error Handling","text":"<pre><code>begin\n  extracted = facts.extract_facts(source.id, extractor: :llm)\nrescue FactDb::ConfigurationError =&gt; e\n  # LLM not configured or ruby_llm missing\n  puts \"LLM Error: #{e.message}\"\n  # Fall back to rule-based\n  extracted = facts.extract_facts(source.id, extractor: :rule_based)\nrescue StandardError =&gt; e\n  # API error, rate limit, etc.\n  puts \"Extraction failed: #{e.message}\"\nend\n</code></pre>"},{"location":"guides/llm-integration/#batch-processing-with-llm","title":"Batch Processing with LLM","text":"<p>Process multiple documents efficiently:</p> <pre><code>source_ids = [content1.id, content2.id, content3.id]\n\n# Parallel processing (uses simple_flow pipeline)\nresults = facts.batch_extract(source_ids, extractor: :llm, parallel: true)\n\nresults.each do |result|\n  if result[:error]\n    puts \"Error for #{result[:source_id]}: #{result[:error]}\"\n  else\n    puts \"Extracted #{result[:facts].count} facts from #{result[:source_id]}\"\n  end\nend\n</code></pre>"},{"location":"guides/llm-integration/#cost-optimization","title":"Cost Optimization","text":""},{"location":"guides/llm-integration/#use-appropriate-models","title":"Use Appropriate Models","text":"<pre><code># For simple extractions, use smaller models\nconfig.llm.model = \"gpt-4o-mini\"  # Cheaper than gpt-4o\n\n# For complex documents, use larger models\nconfig.llm.model = \"gpt-4o\"\n</code></pre>"},{"location":"guides/llm-integration/#batch-processing","title":"Batch Processing","text":"<pre><code># Process in batches to reduce API calls\nsource_ids.each_slice(10) do |batch|\n  facts.batch_extract(batch, extractor: :llm)\n  sleep(1)  # Rate limiting\nend\n</code></pre>"},{"location":"guides/llm-integration/#local-models","title":"Local Models","text":"<pre><code># Use Ollama for development/testing\nFactDb.configure do |config|\n  config.llm.provider = :ollama\n  config.llm.model = \"llama3.2\"\nend\n</code></pre>"},{"location":"guides/llm-integration/#testing","title":"Testing","text":"<p>Mock LLM responses in tests:</p> <pre><code>class MockLLMClient\n  def chat(prompt)\n    # Return predictable test data\n    '{\"facts\": [{\"text\": \"Test fact\", \"valid_at\": \"2024-01-01\", \"entities\": [], \"confidence\": 0.9}]}'\n  end\nend\n\nFactDb.configure do |config|\n  config.llm_client = MockLLMClient.new\nend\n</code></pre>"},{"location":"guides/llm-integration/#best-practices","title":"Best Practices","text":""},{"location":"guides/llm-integration/#1-validate-extractions","title":"1. Validate Extractions","text":"<pre><code>extracted = facts.extract_facts(source.id, extractor: :llm)\n\nextracted.each do |fact|\n  # Flag low-confidence extractions\n  if fact.confidence &lt; 0.7\n    fact.update!(metadata: { needs_review: true })\n  end\nend\n</code></pre>"},{"location":"guides/llm-integration/#2-use-caching","title":"2. Use Caching","text":"<pre><code># Cache LLM responses for repeated content\ncache_key = \"llm_extraction:#{source.content_hash}\"\nextracted = Rails.cache.fetch(cache_key) do\n  facts.extract_facts(source.id, extractor: :llm)\nend\n</code></pre>"},{"location":"guides/llm-integration/#3-handle-rate-limits","title":"3. Handle Rate Limits","text":"<pre><code>require 'retryable'\n\nRetryable.retryable(tries: 3, sleep: 5) do\n  facts.extract_facts(source.id, extractor: :llm)\nend\n</code></pre>"},{"location":"guides/llm-integration/#4-monitor-usage","title":"4. Monitor Usage","text":"<pre><code># Track extraction statistics\nextracted = facts.extract_facts(source.id, extractor: :llm)\nStatsD.increment('fact_db.llm_extractions')\nStatsD.histogram('fact_db.facts_per_content', extracted.count)\n</code></pre>"},{"location":"guides/temporal-queries/","title":"Temporal Queries","text":"<p>FactDb's temporal query system lets you retrieve facts across time - what's true now, what was true then, and how things changed.</p>"},{"location":"guides/temporal-queries/#current-facts","title":"Current Facts","text":"<p>Get facts that are valid right now:</p> <pre><code>facts = FactDb.new\n\n# All currently valid canonical facts\ncurrent = facts.query_facts(status: :canonical)\n\n# Current facts about a specific entity\ncurrent_about_paula = facts.current_facts_for(paula.id)\n\n# Current facts on a topic\nengineering_facts = facts.query_facts(topic: \"engineering\", status: :canonical)\n</code></pre>"},{"location":"guides/temporal-queries/#point-in-time-queries","title":"Point-in-Time Queries","text":"<p>What was true at a specific moment:</p> <pre><code># What did we know about Paula on June 15, 2023?\nhistorical = facts.facts_at(\n  Date.parse(\"2023-06-15\"),\n  entity: paula.id\n)\n\n# What did we know about Microsoft on Jan 1, 2024?\nmicrosoft_facts = facts.facts_at(\n  Date.parse(\"2024-01-01\"),\n  entity: microsoft.id\n)\n</code></pre>"},{"location":"guides/temporal-queries/#time-range-queries","title":"Time Range Queries","text":"<p>Facts active during a period:</p> <pre><code># Facts valid during Q4 2023\nq4_facts = facts.fact_service.query(\n  from: Date.parse(\"2023-10-01\"),\n  to: Date.parse(\"2023-12-31\")\n)\n\n# Paula's employment history for 2023\npaula_2023 = facts.fact_service.query(\n  entity: paula.id,\n  from: Date.parse(\"2023-01-01\"),\n  to: Date.parse(\"2023-12-31\")\n)\n</code></pre>"},{"location":"guides/temporal-queries/#timelines","title":"Timelines","text":"<p>Build complete timelines for entities:</p> <pre><code># Full timeline\ntimeline = facts.timeline_for(paula.id)\n\ntimeline.each do |fact|\n  range = fact.invalid_at ? \"#{fact.valid_at} - #{fact.invalid_at}\" : \"#{fact.valid_at} - present\"\n  puts \"#{range}: #{fact.text}\"\nend\n\n# Timeline for specific period\ntimeline = facts.timeline_for(\n  paula.id,\n  from: Date.parse(\"2023-01-01\"),\n  to: Date.parse(\"2024-12-31\")\n)\n</code></pre>"},{"location":"guides/temporal-queries/#timeline-output-example","title":"Timeline Output Example","text":"<pre><code>2022-03-15 - 2023-01-09: Paula Chen is Software Engineer at Company\n2023-01-10 - 2024-01-09: Paula Chen is Senior Engineer at Company\n2024-01-10 - present: Paula Chen is Principal Engineer at Microsoft\n</code></pre>"},{"location":"guides/temporal-queries/#filtering-by-status","title":"Filtering by Status","text":"<p>Query facts by their status:</p> <pre><code># Only canonical (current authoritative) facts\ncanonical = facts.query_facts(status: :canonical)\n\n# Only corroborated (confirmed by multiple sources) facts\ncorroborated = facts.query_facts(status: :corroborated)\n\n# Include both canonical and corroborated\ntrusted = facts.query_facts(status: [:canonical, :corroborated])\n\n# Superseded facts (historical)\nsuperseded = facts.query_facts(status: :superseded)\n\n# Synthesized facts (derived)\nsynthesized = facts.query_facts(status: :synthesized)\n</code></pre>"},{"location":"guides/temporal-queries/#topic-search","title":"Topic Search","text":"<p>Search facts by text content:</p> <pre><code># Full-text search\nengineering_facts = facts.query_facts(topic: \"engineering\")\n\n# Combined with entity filter\npaula_engineering = facts.query_facts(\n  entity: paula.id,\n  topic: \"promotion\"\n)\n\n# Combined with time filter\nrecent_engineering = facts.query_facts(\n  topic: \"engineering\",\n  at: Date.today\n)\n</code></pre>"},{"location":"guides/temporal-queries/#advanced-queries","title":"Advanced Queries","text":""},{"location":"guides/temporal-queries/#using-scopes","title":"Using Scopes","text":"<pre><code># Direct ActiveRecord queries on Fact model\nfacts = FactDb::Models::Fact\n  .canonical\n  .currently_valid\n  .mentioning_entity(paula.id)\n  .search_text(\"engineer\")\n  .order(valid_at: :desc)\n</code></pre>"},{"location":"guides/temporal-queries/#available-scopes","title":"Available Scopes","text":"Scope Description <code>canonical</code> Status is 'canonical' <code>currently_valid</code> invalid_at is nil <code>valid_at(date)</code> Valid at specific date <code>valid_during(from, to)</code> Valid during range <code>mentioning_entity(id)</code> Mentions specific entity <code>search_text(query)</code> Full-text search <code>by_extraction_method(method)</code> Filter by extractor <code>high_confidence</code> Confidence &gt; 0.8"},{"location":"guides/temporal-queries/#combining-scopes","title":"Combining Scopes","text":"<pre><code># High-confidence facts about Paula currently valid\nfacts = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .canonical\n  .currently_valid\n  .high_confidence\n\n# LLM-extracted facts from last month\nfacts = FactDb::Models::Fact\n  .by_extraction_method('llm')\n  .where('created_at &gt; ?', 1.month.ago)\n</code></pre>"},{"location":"guides/temporal-queries/#semantic-search","title":"Semantic Search","text":"<p>Search by meaning using embeddings:</p> <pre><code># Find facts semantically similar to a query\nsimilar_facts = facts.fact_service.semantic_search(\n  \"Paula's career progression\",\n  limit: 10\n)\n\n# Combined with entity filter\nsimilar_about_paula = facts.fact_service.semantic_search(\n  \"job title changes\",\n  entity: paula.id,\n  limit: 5\n)\n</code></pre>"},{"location":"guides/temporal-queries/#query-results","title":"Query Results","text":""},{"location":"guides/temporal-queries/#fact-attributes","title":"Fact Attributes","text":"<pre><code>fact = facts.query_facts(entity: paula.id).first\n\nfact.text        # The assertion text\nfact.valid_at         # When it became true\nfact.invalid_at       # When it stopped (nil if current)\nfact.status           # canonical, superseded, etc.\nfact.confidence       # 0.0 to 1.0\nfact.extraction_method # manual, llm, rule_based\nfact.metadata         # Additional data\n</code></pre>"},{"location":"guides/temporal-queries/#related-data","title":"Related Data","text":"<pre><code># Entity mentions\nfact.entity_mentions.each do |mention|\n  puts \"#{mention.entity.name} (#{mention.mention_role})\"\nend\n\n# Source content\nfact.fact_sources.each do |fact_source|\n  puts \"Source: #{fact_source.source.title}\"\n  puts \"Excerpt: #{fact_source.excerpt}\"\nend\n\n# Superseding fact\nif fact.superseded?\n  new_fact = fact.superseded_by\n  puts \"Superseded by: #{new_fact.text}\"\nend\n\n# Source facts (for synthesized)\nif fact.synthesized?\n  fact.derived_from_ids.each do |id|\n    source = FactDb::Models::Fact.find(id)\n    puts \"Derived from: #{source.text}\"\n  end\nend\n</code></pre>"},{"location":"guides/temporal-queries/#performance-tips","title":"Performance Tips","text":""},{"location":"guides/temporal-queries/#use-indexes","title":"Use Indexes","text":"<p>The temporal indexes are optimized for:</p> <pre><code># These queries are fast\nfacts.facts_at(Date.today)\nfacts.query_facts(entity: id, status: :canonical)\n</code></pre>"},{"location":"guides/temporal-queries/#limit-results","title":"Limit Results","text":"<pre><code># Always limit when possible\nqueried = facts.fact_service.query(\n  entity: paula.id,\n  limit: 100\n)\n</code></pre>"},{"location":"guides/temporal-queries/#eager-load-associations","title":"Eager Load Associations","text":"<pre><code>facts = FactDb::Models::Fact\n  .includes(:entity_mentions, :fact_sources)\n  .mentioning_entity(paula.id)\n</code></pre>"},{"location":"guides/temporal-queries/#use-count-for-totals","title":"Use Count for Totals","text":"<pre><code># Don't load all records just to count\ntotal = FactDb::Models::Fact.canonical.currently_valid.count\n</code></pre>"},{"location":"guides/temporal-queries/#common-patterns","title":"Common Patterns","text":""},{"location":"guides/temporal-queries/#beforeafter-comparison","title":"Before/After Comparison","text":"<pre><code># What changed for Paula?\nbefore = facts.facts_at(Date.parse(\"2023-12-31\"), entity: paula.id)\nafter = facts.facts_at(Date.parse(\"2024-01-31\"), entity: paula.id)\n\n# Find differences\nnew_facts = after - before\n</code></pre>"},{"location":"guides/temporal-queries/#audit-trail","title":"Audit Trail","text":"<pre><code># Get complete history of a topic\nall_facts = FactDb::Models::Fact\n  .mentioning_entity(paula.id)\n  .search_text(\"title\")\n  .order(valid_at: :asc)\n\nall_facts.each do |fact|\n  status_info = fact.superseded? ? \"(superseded)\" : \"(current)\"\n  puts \"#{fact.valid_at}: #{fact.text} #{status_info}\"\nend\n</code></pre>"},{"location":"guides/temporal-queries/#change-detection","title":"Change Detection","text":"<pre><code># Find facts that changed recently\nrecently_superseded = FactDb::Models::Fact\n  .where(status: 'superseded')\n  .where('invalid_at &gt; ?', 1.week.ago)\n  .includes(:superseded_by)\n\nrecently_superseded.each do |old_fact|\n  puts \"Changed: #{old_fact.text}\"\n  puts \"To: #{old_fact.superseded_by.text}\"\nend\n</code></pre>"}]}